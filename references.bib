@article{banerjee_stack-based_2005,
	title = {Stack-based access control and secure information flow},
	volume = {15},
	issn = {1469-7653},
	url = {http://journals.cambridge.org/article_S0956796804005453},
	doi = {10.1017/S0956796804005453},
	abstract = {Access control mechanisms are often used with the intent of enforcing confidentiality and integrity policies, but few rigorous connections have been made between information flow and runtime access control. The Java virtual machine and the .{NET} runtime system provide a dynamic access control mechanism in which permissions are granted to program units and a runtime mechanism checks permissions of code in the calling chain. We investigate a design pattern by which this mechanism can be used to achieve confidentiality and integrity goals: a single interface serves callers of more than one security level and dynamic access control prevents release of high information to low callers. Programs fitting this pattern would be rejected by previous flow analyses. We give a static analysis that admits them, using permission-dependent security types. The analysis is given for a class-based object-oriented language with features including inheritance, dynamic binding, dynamically allocated mutable objects, type casts and recursive types. The analysis is shown to ensure a noninterference property formalizing confidentiality and integrity.},
	number = {02},
	urldate = {2014-10-09},
	journal = {Journal of Functional Programming},
	author = {Banerjee, Anindya and Naumann, David A.},
	month = mar,
	year = {2005},
	pages = {131--177}
}

@inproceedings{QualitasCorpus:APSEC:2010,
  author = {Tempero, Ewan and Anslow, Craig and Dietrich, Jens and Han, Ted and Li, Jing and Lumpe, Markus and Melton, Hayden and Noble, James},
  title = {Qualitas Corpus: A Curated Collection of Java Code for Empirical Studies},
  booktitle = {2010 Asia Pacific Software Engineering Conference (APSEC2010)},
  pages = {336--345},
  month = dec,
  year = {2010},
  doi = {http://dx.doi.org/10.1109/APSEC.2010.46}
}

@inproceedings{besson_stack_2004,
	title = {From stack inspection to access control: {A} security analysis for libraries},
	shorttitle = {From stack inspection to access control},
	doi = {10.1109/CSFW.2004.1310732},
	abstract = {We present a new static analysis for reviewing the security of libraries for systems, such as {JVMs} or the {CLR}, that rely on stack inspection for access control. We describe its implementation for the {CLR}. Our tool inputs a set of libraries plus a description of the permissions granted to unknown, potentially hostile code. It constructs a permission-sensitive call graph, which can be queried to identify potential security defects. It has been applied to large pre-existing libraries. We also develop a new formal model of the essentials of access control in the {CLR} (types, classes and inheritance, access modifiers, permissions, and stack inspection). In this model, we state and prove the correctness of the analysis.},
	booktitle = {17th {IEEE} Computer Security Foundations Workshop, 2004. Proceedings},
	author = {Besson, F. and Blanc, T. and Fournet, C. and Gordon, A.D.},
	month = jun,
	year = {2004},
	keywords = {Access Control, access modifier, authorisation, {CLR}, Documentation, formal model, Inspection, Java, {JVM}, object-oriented programming, Permission, permission-sensitive call graph, potentially hostile code, potential security defects, program diagnostics, Runtime library, Security, security analysis, Software libraries, stack inspection, Static Analysis, Testing, Virtual machining},
	pages = {61--75},
	file = {IEEE Xplore Abstract Record:/home/mmaass/.mozilla/firefox/4lnfai0n.default/zotero/storage/VHWJUIZS/articleDetails.html:text/html}
}

@inproceedings{cappos_retaining_2010,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '10},
	title = {Retaining Sandbox Containment Despite Bugs in Privileged Memory-safe Code},
	isbn = {978-1-4503-0245-6},
	url = {http://doi.acm.org/10.1145/1866307.1866332},
	doi = {10.1145/1866307.1866332},
	abstract = {Flaws in the standard libraries of secure sandboxes represent a major security threat to billions of devices worldwide. The standard libraries are hard to secure because they frequently need to perform low-level operations that are forbidden in untrusted application code. Existing designs have a single, large trusted computing base that contains security checks at the boundaries between trusted and untrusted code. Unfortunately, flaws in the standard library often allow an attacker to escape the security protections of the sandbox. In this work, we construct a Python-based sandbox that has a small, security-isolated kernel. Using a mechanism called a security layer, we migrate privileged functionality into memory-safe code on top of the sandbox kernel while retaining isolation. For example, significant portions of module import, file I/O, serialization, and network communication routines can be provided in security layers. By moving these routines out of the kernel, we prevent attackers from leveraging bugs in these routines to evade sandbox containment. We demonstrate the effectiveness of our approach by studying past bugs in Java's standard libraries and show that most of these bugs would likely be contained in our sandbox},
	urldate = {2014-10-10},
	booktitle = {Proceedings of the 17th {ACM} Conference on Computer and Communications Security},
	publisher = {{ACM}},
	author = {Cappos, Justin and Dadgar, Armon and Rasley, Jeff and Samuel, Justin and Beschastnikh, Ivan and Barsan, Cosmin and Krishnamurthy, Arvind and Anderson, Thomas},
	year = {2010},
	keywords = {containment, layering, sandbox},
	pages = {212--223}
}

@inproceedings{cova_detection_2010,
	address = {New York, {NY}, {USA}},
	series = {{WWW} '10},
	title = {Detection and {A}nalysis of {D}rive-by-download {A}ttacks and {M}alicious {JavaScript} {C}ode},
	isbn = {978-1-60558-799-8},
	url = {http://doi.acm.org/10.1145/1772690.1772720},
	doi = {10.1145/1772690.1772720},
	abstract = {{JavaScript} is a browser scripting language that allows developers to create sophisticated client-side interfaces for web applications. However, {JavaScript} code is also used to carry out attacks against the user's browser and its extensions. These attacks usually result in the download of additional malware that takes complete control of the victim's platform, and are, therefore, called "drive-by downloads." Unfortunately, the dynamic nature of the {JavaScript} language and its tight integration with the browser make it difficult to detect and block malicious {JavaScript} code. This paper presents a novel approach to the detection and analysis of malicious {JavaScript} code. Our approach combines anomaly detection with emulation to automatically identify malicious {JavaScript} code and to support its analysis. We developed a system that uses a number of features and machine-learning techniques to establish the characteristics of normal {JavaScript} code. Then, during detection, the system is able to identify anomalous {JavaScript} code by emulating its behavior and comparing it to the established profiles. In addition to identifying malicious code, the system is able to support the analysis of obfuscated code and to generate detection signatures for signature-based systems. The system has been made publicly available and has been used by thousands of analysts.},
	urldate = {2014-10-13},
	booktitle = {Proceedings of the 19th International Conference on World Wide Web},
	publisher = {{ACM}},
	author = {Cova, Marco and Kruegel, Christopher and Vigna, Giovanni},
	year = {2010},
	keywords = {Anomaly Detection, drive-by-download attacks, web client exploits},
	pages = {281--290},
	file = {ACM Full Text PDF:/home/mmaass/.mozilla/firefox/4lnfai0n.default/zotero/storage/BBFMGAWJ/Cova et al. - 2010 - Detection and Analysis of Drive-by-download Attack.pdf:application/pdf}
}


@article{d._s._wallach_understanding_1998,
	title = {Understanding {J}ava {S}tack {I}nspection},
	issn = {1081-6011},
	doi = {10.1109/SECPRI.1998.674823},
	author = {D. S. Wallach, E. W. Felten},
	year = {1998},
	pages = {52--63},
	file = {Understanding Java stack inspection - ResearchGate:/home/mmaass/.mozilla/firefox/4lnfai0n.default/zotero/storage/5W52KMJM/3748086_Understanding_Java_stack_inspection.html:text/html}
}

@inproceedings{erlingsson_irm_2000,
	title = {{IRM} {E}nforcement of {J}ava {S}tack {I}nspection},
	doi = {10.1109/SECPRI.2000.848461},
	abstract = {Two implementations are given for Java's stack inspection access-control policy. Each implementation is obtained by generating an inlined reference monitor ({IRM}) for a different formulation of the policy. Performance of the implementations is evaluated, and one is found to be competitive with Java's less flexible, {JVM}-resident implementation. The exercise illustrates the power of the {IRM} approach for enforcing security policies},
	booktitle = {2000 {IEEE} Symposium on Security and Privacy, 2000. S P 2000. Proceedings},
	author = {{Erlingsson} and Schneider, F.B.},
	year = {2000},
	keywords = {authorisation, Binary codes, Computerized monitoring, Computer science, Decoding, distributed programming, Genetics, inlined reference monitor, Inspection, {IRM} approach, {IRM} enforcement, Java, Java stack inspection, {JVM}-resident implementation, Power system security, Runtime, security policy enforcement, stack inspection access-control policy, virtual machines, Virtual machining},
	pages = {246--255}
}

@inproceedings{garber_2012,
	title = {{H}ave {J}ava's {S}ecurity {I}ssues {G}otten out of {H}and?},	
	booktitle = {2012 {IEEE} Technology News},
	author = {Lee Garber},
	year = {2012},
	pages = {18--21}
}

@inproceedings{ford_analyzing_2009,
	address = {Washington, {DC}, {USA}},
	series = {{ACSAC} '09},
	title = {Analyzing and {D}etecting {M}alicious {F}lash {A}dvertisements},
	isbn = {978-0-7695-3919-5},
	url = {http://dx.doi.org/10.1109/ACSAC.2009.41},
	doi = {10.1109/ACSAC.2009.41},
	abstract = {The amount of dynamic content on the web has been steadily increasing. Scripting languages such as {JavaScript} and browser extensions such as Adobe's Flash have been instrumental in creating web-based interfaces that are similar to those of traditional applications. Dynamic content has also become popular in advertising, where Flash is used to create rich, interactive ads that are displayed on hundreds of millions of computers per day. Unfortunately, the success of Flash-based advertisements and applications attracted the attention of malware authors, who started to leverage Flash to deliver attacks through advertising networks. This paper presents a novel approach whose goal is to automate the analysis of Flash content to identify malicious behavior. We designed and implemented a tool based on the approach, and we tested it on a large corpus of real-world Flash advertisements. The results show that our tool is able to reliably detect malicious Flash ads with limited false positives. We made our tool available publicly and it is routinely used by thousands of users.},
	urldate = {2014-10-13},
	booktitle = {Proceedings of the 2009 Annual Computer Security Applications Conference},
	publisher = {{IEEE} Computer Society},
	author = {Ford, Sean and Cova, Marco and Kruegel, Christopher and Vigna, Giovanni},
	year = {2009},
	pages = {363--372}
}

@inproceedings{fournet_stack_2002,
	address = {New York, {NY}, {USA}},
	series = {{POPL} '02},
	title = {{S}tack {I}nspection: {T}heory and {V}ariants},
	isbn = {1-58113-450-9},
	shorttitle = {Stack Inspection},
	url = {http://doi.acm.org/10.1145/503272.503301},
	doi = {10.1145/503272.503301},
	abstract = {Stack inspection is a security mechanism implemented in runtimes such as the {JVM} and the {CLR} to accommodate components with diverse levels of trust. Although stack inspection enables the fine-grained expression of access control policies, it has rather a complex and subtle semantics. We present a formal semantics and an equational theory to explain how stack inspection affects program behaviour and code optimisations. We discuss the security properties enforced by stack inspection, and also consider variants with stronger, simpler properties.},
	urldate = {2014-10-09},
	booktitle = {Proceedings of the 29th {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	publisher = {{ACM}},
	author = {Fournet, Cédric and Gordon, Andrew D.},
	year = {2002},
	pages = {307--318}
}

@article{hardy_confused_1988,
	title = {The {C}onfused {D}eputy: (or {W}hy {C}apabilities {M}ight {H}ave {B}een {I}nvented)},
	volume = {22},
	issn = {0163-5980},
	shorttitle = {The Confused Deputy},
	url = {http://dl.acm.org/citation.cfm?id=54289.871709},
	number = {4},
	urldate = {2014-10-09},
	journal = {{SIGOPS} Oper. Syst. Rev.},
	author = {Hardy, Norm},
	month = oct,
	year = {1988},
	pages = {36--38}
}

@article{helmer_anomalous_2001,
	title = {Anomalous {I}ntrusion {D}etection {S}ystem for {H}ostile {J}ava {A}pplets},
	volume = {55},
	issn = {0164-1212},
	url = {http://dx.doi.org/10.1016/S0164-1212(00)00076-5},
	doi = {10.1016/S0164-1212(00)00076-5},
	number = {3},
	urldate = {2014-10-13},
	journal = {J. Syst. Softw.},
	author = {Helmer, Guy and Wong, Johnny and Madaka, Subhasri},
	month = jan,
	year = {2001},
	keywords = {anomalous intrusion detection, applet, intrusion detection system, machine learning algorithm, misuse intrusion detection, {RIPPER}, system call sequence, vector},
	pages = {273--286}
}

@article{hovemeyer_finding_2004,
	title = {Finding Bugs is Easy},
	volume = {39},
	issn = {0362-1340},
	url = {http://doi.acm.org/10.1145/1052883.1052895},
	doi = {10.1145/1052883.1052895},
	abstract = {Many techniques have been developed over the years to automatically find bugs in software. Often, these techniques rely on formal methods and sophisticated program analysis. While these techniques are valuable, they can be difficult to apply, and they aren't always effective in finding real bugs.Bug patterns are code idioms that are often errors. We have implemented automatic detectors for a variety of bug patterns found in Java programs. In this paper, we describe how we have used bug pattern detectors to find serious bugs in several widely used Java applications and libraries. We have found that the effort required to implement a bug pattern detector tends to be low, and that even extremely simple detectors find bugs in real applications.From our experience applying bug pattern detectors to real programs, we have drawn several interesting conclusions. First, we have found that even well tested code written by experts contains a surprising number of obvious bugs. Second, Java (and similar languages) have many language features and {APIs} which are prone to misuse. Finally, that simple automatic techniques can be effective at countering the impact of both ordinary mistakes and misunderstood language features.},
	number = {12},
	urldate = {2014-10-09},
	journal = {{SIGPLAN} Not.},
	author = {Hovemeyer, David and Pugh, William},
	month = dec,
	year = {2004},
	pages = {92--106}
}

@inproceedings{li_quarantine:_2011,
	address = {New York, {NY}, {USA}},
	series = {{PPPJ} '11},
	title = {Quarantine: {A} {F}ramework to {M}itigate {M}emory {E}rrors in {JNI} {A}pplications},
	isbn = {978-1-4503-0935-6},
	shorttitle = {Quarantine},
	url = {http://doi.acm.org/10.1145/2093157.2093159},
	doi = {10.1145/2093157.2093159},
	abstract = {By using Java Native Interface ({JNI}), programmers can integrate Java programs with legacy applications or third-party libraries written in other languages (e.g., C, C++, and Pascal). However, the use of {JNI} can bypass the Java boundary checking and exception-handling mechanisms. Furthermore, its use can violate Java's type-safety feature because of the type-mismatches between native programs and Java programs. As a result, such integration can cause various security issues including heap errors that can be dangerous and difficult to detect. In this paper, we introduce Quarantine, a runtime system that can identify objects accessible by native methods and then migrate these objects to a quarantine area, which is used specifically to host this type of object. The goal of Quarantine is to create a runtime platform that allows programmers to apply existing heap protection techniques that have been designed for native languages but do not work well in the Java domain. We implemented Quarantine in Jikes {RVM} and evaluated its performance using the optimizing compiler. Our results using nine benchmark programs indicate that Quarantine, on average, incurs execution overhead of 14\% and 13\% when the heap is two and five times larger than the minimum heap requirement for an application, respectively.},
	urldate = {2014-10-10},
	booktitle = {Proceedings of the 9th International Conference on Principles and Practice of Programming in Java},
	publisher = {{ACM}},
	author = {Li, Du and Srisa-an, Witawas},
	year = {2011},
	keywords = {heap protection, Java, {JNI}, virtual machine},
	pages = {1--10}
}

@book{long_cert_2011,
	edition = {1st},
	series = {{SEI} {S}eries in {S}oftware {E}ngineering},
	title = {The {CERT} {O}racle {S}ecure {C}oding {S}tandard for {J}ava},
	isbn = {978-0-321-80395-5},
	publisher = {Addison-Wesley Professional},
	author = {Long, Fred and Mohindra, Dhruv and Seacord, Robert C. and Sutherland, Dean F. and Svoboda, David},
	month = sep,
	year = {2011}
}

@misc{_permissions_2014,
	title = {Permissions in the {JDK}},
	url = {http://docs.oracle.com/javase/7/docs/technotes/guides/security/permissions.html},
	urldate = {2014-10-09},
	journal = {Java {SE} Documentation},
	year = {2014}
}

@inproceedings{pistoia_beyond_2007,
	title = {Beyond {S}tack {I}nspection: {A} {U}nified {A}ccess-{C}ontrol and {I}nformation-{F}low {S}ecurity {M}odel},
	shorttitle = {Beyond Stack Inspection},
	doi = {10.1109/SP.2007.10},
	abstract = {Modern component-based systems, such as Java and Microsoft .{NET} common language runtime ({CLR}), have adopted stack-based access control ({SBAC}). Its purpose is to use stack inspection to verify that all the code responsible for a security-sensitive action is sufficiently authorized to perform that action. Previous literature has shown that the security model enforced by {SBAC} is flawed in that stack inspection may allow unauthorized code no longer on the stack to influence the execution of security-sensitive code. A different approach, history-based access control ({HBAC}), is safe but may prevent authorized code from executing a security-sensitive operation if less trusted code was previously executed. In this paper, we formally introduce information-based access control ({IBAC}), a novel security model that verifies that all and only the code responsible for a security-sensitive operation is sufficiently authorized. Given an access-control policy a, we present a mechanism to extract from it an implicit integrity policy i, and we prove that {IBAC} enforces i. Furthermore, we discuss large-scale application code scenarios to which {IBAC} can be successfully applied.},
	booktitle = {{IEEE} Symposium on Security and Privacy, 2007. {SP} '07},
	author = {Pistoia, M. and Banerjee, A. and Naumann, D.A.},
	month = may,
	year = {2007},
	keywords = {Access Control, authorisation, authorization, code verification, component-based system, data flow analysis, data integrity, history-based access control, information-flow security model, Information security, Inspection, Java, large-scale systems, Microsoft .{NET} common language runtime, object-oriented programming, Permission, program verification, Runtime, stack inspection, Testing, unified access-control},
	pages = {149--163}
}

@inproceedings{schlumberger_jarhead_2012,
	address = {New York, {NY}, {USA}},
	series = {{ACSAC} '12},
	title = {Jarhead {A}nalysis and {D}etection of {M}alicious {J}ava {A}pplets},
	isbn = {978-1-4503-1312-4},
	url = {http://doi.acm.org/10.1145/2420950.2420988},
	doi = {10.1145/2420950.2420988},
	abstract = {Java applets have increasingly been used as a vector to deliver drive-by download attacks that bypass the sandboxing mechanisms of the browser's Java Virtual Machine and compromise the user's environment. Unfortunately, the research community has not given to this problem the attention it deserves, and, as a consequence, the state-of-the-art approaches to the detection of malicious Java applets are based either on simple signatures or on the use of honey-clients, which are both easily evaded. Therefore, we propose a novel approach to the detection of malicious Java applets based on static code analysis. Our approach extracts a number of features from Java applets, and then uses supervised machine learning to produce a classifier. We implemented our approach in a tool, called Jarhead, and we tested its effectiveness on a large, real-world dataset. The results of the evaluation show that, given a sufficiently large training dataset, this approach is able to reliably detect both known and previously-unseen real-world malicious applets.},
	urldate = {2014-10-13},
	booktitle = {Proceedings of the 28th Annual Computer Security Applications Conference},
	publisher = {{ACM}},
	author = {Schlumberger, Johannes and Kruegel, Christopher and Vigna, Giovanni},
	year = {2012},
	pages = {249--257},
	file = {ACM Full Text PDF:/home/mmaass/.mozilla/firefox/4lnfai0n.default/zotero/storage/NTTUZBC9/Schlumberger et al. - 2012 - Jarhead Analysis and Detection of Malicious Java A.pdf:application/pdf}
}

@techreport{security_explorations_2012,
	type = {Technical Report},
	title = {Security {V}ulnerabilities in {J}ava {SE}},
	url = {http://www.security-explorations.com/materials/se-2012-01-report.pdf},
	number = {{SE}-2012-01 Project},
	institution = {Security Explorations},
	year = {2012}
}

@techreport{blackhat_2012,
	type = {Technical Report},
	title = {Recent {J}ava exploitation trends and malware},
	url = {https://media.blackhat.com/bh-us-12/Briefings/Oh/BH_US_12_Oh_Recent_Java_Exploitation_Trends_and_Malware_WP.pdf},
	institution = {Black Hat},
	year = {2012}
}

@inproceedings{siefers_robusta:_2010,
	address = {New York, {NY}, {USA}},
	series = {{CCS} '10},
	title = {Robusta: {T}aming the {N}ative {B}east of the {JVM}},
	isbn = {978-1-4503-0245-6},
	shorttitle = {Robusta},
	url = {http://doi.acm.org/10.1145/1866307.1866331},
	doi = {10.1145/1866307.1866331},
	abstract = {Java applications often need to incorporate native-code components for efficiency and for reusing legacy code. However, it is well known that the use of native code defeats Java's security model. We describe the design and implementation of Robusta, a complete framework that provides safety and security to native code in Java applications. Starting from software-based fault isolation ({SFI}), Robusta isolates native code into a sandbox where dynamic linking/loading of libraries in supported and unsafe system modification and confidentiality violations are prevented. It also mediates native system calls according to a security policy by connecting to Java's security manager. Our prototype implementation of Robusta is based {onNative} Client and {OpenJDK}. Experiments in this prototype demonstrate Robusta is effective and efficient, with modest runtime overhead on a set of {JNI} benchmark programs. Robusta can be used to sandbox native libraries used in Java's system classes to prevent attackers from exploiting bugs in the libraries. It can also enable trustworthy execution of mobile Java programs with native libraries. The design of Robusta should also be applicable when other type-safe languages (e.g., C\#, Python) want to ensure safe interoperation with native libraries},
	urldate = {2014-10-10},
	booktitle = {Proceedings of the 17th {ACM} Conference on Computer and Communications Security},
	publisher = {{ACM}},
	author = {Siefers, Joseph and Tan, Gang and Morrisett, Greg},
	year = {2010},
	keywords = {{JNI}, {JVM}, Sandboxing, {SFI}},
	pages = {201--211}
}

@incollection{sun_jvm-portable_2012,
	series = {Lecture Notes in Computer Science},
	title = {{JVM}-Portable Sandboxing of Java's Native Libraries},
	copyright = {(c)2012 Springer-Verlag Berlin Heidelberg},
	isbn = {978-3-642-33166-4, 978-3-642-33167-1},
	url = {http://link.springer.com/chapter/10.1007/978-3-642-33167-1_48},
	abstract = {Although Java provides strong support for safety and security, native libraries used in a Java application can open security holes. Previous work, Robusta, puts native libraries in a sandbox to protect the integrity and security of Java. However, Robusta’s implementation modifies the internals of {OpenJDK}, a particular implementation of a Java Virtual Machine ({JVM}). As such, it is not portable to other {JVM} implementations. This paper shows how to make the idea of sandboxing native libraries {JVM}-portable. We present a two-layer approach for sandboxing without modifying the internals of a {JVM}. We also discuss our experience of sandboxing Java’s core native libraries. Experiments show that our approach of {JVM}-portable sandboxing incurs modest performance overhead on {SPECjvm} 2008 benchmark programs.},
	language = {en},
	number = {7459},
	urldate = {2014-10-10},
	booktitle = {Computer Security - {ESORICS} 2012},
	publisher = {Springer Berlin Heidelberg},
	author = {Sun, Mengtao and Tan, Gang},
	editor = {Foresti, Sara and Yung, Moti and Martinelli, Fabio},
	month = jan,
	year = {2012},
	keywords = {Data Encryption, e-Commerce/e-business, Information Systems Applications (incl. Internet), Management of Computing and Information Systems, software engineering, Systems and Data Security},
	pages = {842--858},
	file = {Snapshot:/home/mmaass/.mozilla/firefox/4lnfai0n.default/zotero/storage/VNT5GXRP/978-3-642-33167-1_48.html:text/html}
}

@misc{svoboda_anatomy_2014,
	address = {San Fransisco, {CA} {USA}},
	title = {Anatomy of {A}nother {J}ava {Z}ero-{D}ay {E}xploit},
	url = {https://oracleus.activeevents.com/2014/connect/sessionDetail.ww?SESSION_ID=2120},
	author = {Svoboda, David and Toda, Yozo},
	month = sep,
	year = {2014}
}

@misc{svoboda_anatomy_blog_2013,
	title = {Anatomy of {J}ava {E}xploits},
	url = {http://www.cert.org/blogs/certcc/post.cfm?EntryID=136},
	urldate = {2014-10-09},
	journal = {{CERT}/{CC} {B}log},
	author = {Svoboda, David}
}

@misc{fireeye_2013,
	institution = {Fire{E}ye},
	title = {Get {S}et {N}ull {J}ava {S}ecurity},
	url = {http://www.fireeye.com/blog/technical/2013/06/get-set-null-java-security.html},
	author = {Singh, Abhishek and Kapoor, Shray},
	month = {June},
	year = {2013}
}

@inproceedings{QualitasCorpus:APSEC:2010,
  author = {Tempero, Ewan and Anslow, Craig and Dietrich, Jens and Han, Ted and Li, Jing and Lumpe, Markus and Melton, Hayden and Noble, James},
  title = {Qualitas Corpus: A Curated Collection of Java Code for Empirical Studies},
  booktitle = {2010 Asia Pacific Software Engineering Conference (APSEC2010)},
  pages = {336--345},
  month = dec,
  year = {2010},
  doi = {http://dx.doi.org/10.1109/APSEC.2010.46}
}

@misc{_vulnerability_2012_0507,
	title = {Vulnerability {S}ummary for {CVE}-2012-0507},
	url = {http://web.nvd.nist.gulnerability Summary for CVE-2012-468ov/view/vuln/detail?vulnId=CVE-2012-0507},
	urldate = {2014-10-09},
	journal = {National {V}ulnerability {D}atabase},
	month = jun,
	year = {2012}
}

@misc{_vulnerability_2012_4681,
	title = {Vulnerability {S}ummary for {CVE}-2012-4681},
	url = {http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2012-4681},
	urldate = {2014-10-09},
	journal = {National {V}ulnerability {D}atabase},
	month = oct,
	year = {2013}
}

@inproceedings{zhao_type_2005,
	title = {{T}ype annotations to improve stack-based access control},
	doi = {10.1109/CSFW.2005.27},
	abstract = {Java security architecture uses stack-based access control to protect security-sensitive resources. The architecture implements access control checks by inspecting the call stack to compute permission levels, which are used to decide whether to grant access to these resources. This implementation only considers the direct and indirect callers of sensitive methods that directly accesses the resources. However, it does not check the integrity of the variables used in the calls to these methods, nor does it help protect confidential values that might be returned by these calls. This paper proposes a type-based approach to strengthen stack-based access control. We use type annotations to track values originated from untrusted code such that these values will not be inputs to the sensitive methods when they are executed with high level of trust. We also use the annotations to protect confidential values from being accidentally revealed by trusted code. We give a static type system that checks these properties and augments existing dynamic stack-based checks. The hybrid approach is similar to so-called "history-based access control" without its run-time burden.},
	booktitle = {Computer Security Foundations, 2005. {CSFW}-18 2005. 18th {IEEE} Workshop},
	author = {Zhao, Tian and Boyland, J.},
	month = jun,
	year = {2005},
	keywords = {Access Control, authorisation, Computer architecture, data encapsulation, history-based access control, Inspection, Java, Java security architecture, Permission, Programming profession, Protection, Runtime, Security, security-sensitive resources, stack-based access control, type annotations, Virtual machining},
	pages = {197--210}
}

@InProceedings{DaCapo:paper,
  title={The {DaCapo} Benchmarks: {J}ava Benchmarking Development and Analysis},
  author={Blackburn, S. M. and Garner, R. and Hoffman, C. and Khan, A. M.
      and McKinley, K. S. and Bentzur, R. and Diwan, A. and Feinberg, D. 
      and Frampton, D. and Guyer, S. Z. and Hirzel, M. and Hosking, A.
      and Jump, M. and Lee, H. and Moss, J. E. B. and Phansalkar, A.
      and Stefanovi\'{c}, D. and {VanDrunen}, T. and von~Dincklage, D.
      and Wiedermann, B.},
  booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-Oriented Programing, Systems, Languages, and Applications},
  month = oct,
  year = {2006},
  pages = {169--190},
  location = {Portland, OR, USA},
  doi = {http://doi.acm.org/10.1145/1167473.1167488},
  publisher = {ACM Press},
  address = {New York, NY, USA},
}
