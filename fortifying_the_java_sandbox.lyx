#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\usepackage{fancyvrb}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Fortifying the Java Sandbox
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Related science:
\end_layout

\begin_layout Plain Layout
1.
 Most Dangerous Code in the World
\end_layout

\begin_layout Plain Layout
2.
 Zero Day Vulnerabilities (Before We Knew It)
\end_layout

\begin_layout Plain Layout
3.
 Password Manager insecurity paper (from Sep 2014)
\end_layout

\begin_layout Plain Layout
Related science probably makes sense to go right before the flag post paragraph.
\end_layout

\begin_layout Plain Layout
This section should define JVMTI so that we can use it everywhere else but
 don't explain much about what it is here -- shouldn't be hard to do (cite
 the docs when doing it)
\end_layout

\begin_layout Plain Layout
Needs to mention JVM to define acronym.
\end_layout

\begin_layout Plain Layout
Be clear right up front that we aren't trying to stop all Java exploits,
 we are trying to harden existing foundations to shore up defenses for future
 mitigations.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Java sandbox was designed to safely execute code from untrusted sources.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sandbox-high-level-summary"

\end_inset

 summarizes the components of the sandbox that are relevant to this work.
 Essentially, when a class loader loads a class from some location (e.g.,
 network, filesystem, etc.) the class is assigned a code source.
 The code source is used to indicate the origin of the code while it is
 loaded in the JRE and to associate the class with a protection domain.
 Protection domains segment the classes in an application into different
 groups that are assigned a security policy.
 Each domain imposes one policy on the classes it contains, where a policy
 includes a set of permissions that grant the contained classes the ability
 to perform operations such as writing to the filesystem, accessing the
 network, using certain reflection features, etc.
 (see a more complete list at 
\begin_inset CommandInset citation
LatexCommand cite
key "_permissions_2014"

\end_inset

).
 Each JRE contains a default policy configuration that grants applications
 from the local filesystem all permissions and applets from the web a strict
 set of permissions that prevent them from performing malicious operations
 on the host system.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename sandbox_overview.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A high-level summary of the Java sandbox as it pertains to this work.
\begin_inset CommandInset label
LatexCommand label
name "fig:Sandbox-high-level-summary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To enforce the security policy, a security manager must be set (typically
 by calling
\family typewriter
 System.setSecurityManager(new SecurityManger())
\family default
).
 The security manager acts as the gateway to policy enforcement in the Java
 sandbox.
 Whenever Java code wants to ensure a caller has the correct permissions
 to execute protected code, the callee must query the security manager.
 For example, if an application attempts to use a JRE class to write to
 a file (e.g 
\family typewriter
java.io.FileOutputStream
\family default
), the JRE class will ensure that the caller has permission to write to
 the file before performing the write.
 When such a query is initiated, the security manager walks the stack frame
 for the current calling context to ensure every class in the context has
 the correct permissions or a privileged caller has marked the context as
 privileged.
 If the context is not marked as privileged and even one class in the stack
 frame does not have the correct permissions, the manager will throw a 
\family typewriter
SecurityException
\family default
.
 Stack-based access control is discussed in more detail in 
\begin_inset CommandInset citation
LatexCommand cite
key "banerjee_stack-based_2005,besson_stack_2004,d._s._wallach_understanding_1998,erlingsson_irm_2000,fournet_stack_2002,pistoia_beyond_2007,zhao_type_2005"

\end_inset

.
 
\end_layout

\begin_layout Standard
Typically a security manager is immediately set when a class is loaded using
 class loaders for sources that are nearly always untrusted such as applets.
 In the case of applets and applications that use the Java Network Launch
 Protocol, the managers are self-protecting in the sense that they don't
 let malicious code change how the sandbox operates or what it constrains.
 It is possible for a manager to be defenseless, which can be useful when
 the manager is being used for purposes that are not security related.
 For example, a unit test may use the manager and dynamically change the
 enforced policy to inject faults into the tested application.
 We discuss this type of use case and others in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Research-Questions-and"

\end_inset

.
\end_layout

\begin_layout Standard
Malicious drive-by downloads using Java applets as the vector were widely
 reported between 2011 and 2013.
 While the security manager should prevent applets from performing operations
 that are useful to a malicious actor, vulnerabilities in the JRE were leveraged
 to set the manager to 
\family typewriter
null
\family default
.
 The latter operation effectively disables the Java sandbox, thus allowing
 previously constrained classes to perform any operation that the JRE can
 perform.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-typical-exploit-payload"

\end_inset

 shows a typical payload.
 An exploit will elevate this payload's privileges to allow it to disable
 the security manager and perform its malicious operations.
 These vulnerabilities tend to fall into one of two categories: those that
 exploit a type confusion vulnerability to set the security manager to 
\family typewriter
null
\family default
 and those that exploit a confused deputy vulnerability 
\begin_inset CommandInset citation
LatexCommand cite
key "hardy_confused_1988"

\end_inset

 in a privileged JRE class to 
\family typewriter
null
\family default
 the security manager.

\series bold
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset listings
lstparams "numbers=left,basicstyle={\tiny}"
inline false
status open

\begin_layout Plain Layout

import java.lang.reflect.Method; 
\end_layout

\begin_layout Plain Layout

import java.security.AccessController; 
\end_layout

\begin_layout Plain Layout

import java.security.PrivilegedExceptionAction;   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Payload implements PrivilegedExceptionAction {         
\end_layout

\begin_layout Plain Layout

    public Payload() {
\end_layout

\begin_layout Plain Layout

        try {
\end_layout

\begin_layout Plain Layout

            AccessController.doPrivileged(this);
\end_layout

\begin_layout Plain Layout

        } catch(Exception exception) { }     
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public Object run() throws Exception {
\end_layout

\begin_layout Plain Layout

        // Disable sandbox
\end_layout

\begin_layout Plain Layout

        Class cl = System.class; 
\end_layout

\begin_layout Plain Layout

        Method m = cl.getMethod("setSecurityManager", 
\end_layout

\begin_layout Plain Layout

            new Class[] { SecurityManager.class }); 
\end_layout

\begin_layout Plain Layout

        m.invoke(null, new Object[1]);
\end_layout

\begin_layout Plain Layout

        return null;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public static void outSandbox() throws Exception {
\end_layout

\begin_layout Plain Layout

        // Do malicious operations
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A typical Java exploit payload from http://pastebin.com/QWU1rqjf.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-typical-exploit-payload"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the case of type confusion a vulnerability is exploited to break type
 safety, thus allowing the attacker to craft an object that can perform
 operations as if it is an instance of a class of a different type.
 For example, attackers will craft objects that either (1) point to the
 
\family typewriter
System
\family default
 class to cause any operation they perform to happen on the real 
\family typewriter
System
\family default
 class, thus allowing them to directly alter the field where the security
 manager is stored or (2) act as if they have the same type as a privileged
 class loader to load a payload class with all permissions (see CVE-2012-0507
 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_0507"

\end_inset

).
 In the case of a confused deputy, the exploit often attacks a privileged
 class that is accessible by any class to obtain an instance of a vulnerable
 privileged class that is only accessible to other privileged classes.
 The restricted-access class is targeted because it contains a vulnerability
 that can be leveraged to execute privileged code, typically to disable
 the security manager (see CVE-2012-4681 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_4681"

\end_inset

).
 While it is possible for an accessible privileged class to contain a vulnerabil
ity that will allow an attacker to disable the manager more directly, these
 classes are typically implemented more carefully to avoid these types of
 issues.
\end_layout

\begin_layout Standard
Many of the recent vulnerabilities would not have been introduced if the
 JRE was developed while strictly following 
\begin_inset Quotes eld
\end_inset

The CERT Oracle Secure Coding Standard for Java
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "long_cert_2011"

\end_inset

.
 For example, Svoboda 
\begin_inset CommandInset citation
LatexCommand cite
key "svoboda_anatomy_blog_2013,svoboda_anatomy_2014"

\end_inset

 pointed out that CVE-2012-0507 and CVE-2012-4681 were caused by violating
 a total of six different secure coding rules and four guidelines.
 In the typical case, following just one or two of the broken rules and
 guidelines would have prevented a serious exploit.
 In the rest of this paper we concern ourselves with ways to fortify the
 Java sandbox without breaking backwards compatibility and not with the
 specifics of particular exploits.
\end_layout

\begin_layout Standard
For the purpose of fortifying the sandbox, we distinguish between self-protectin
g and defenseless security managers.
 A 
\shape italic
self-protecting
\shape default
 security manager enforces a policy that prevents encapsulated classes from
 changing the manager or the policy it enforces.
 In contrast, a 
\shape italic
defenseless
\shape default
 security manager allows encapsulated classes to change the manager or the
 enforced policy.
 A defenseless manager does little to improve the security posture of the
 encapsulated Java application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:defenseless-permissions"

\end_inset

 summarizes the set of permissions used to distinguish between self-protecting
 and defenseless security managers.
 A manager enforcing a policy that contains even one of the listed permissions
 is defenseless.
 A subset of the permissions in this list were identified in 
\begin_inset CommandInset citation
LatexCommand cite
key "security_explorations_2012"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A security manager enforcing a policy that contains any permission in this
 list is defenseless.
\begin_inset CommandInset label
LatexCommand label
name "tab:defenseless-permissions"

\end_inset


\begin_inset Newline newline
\end_inset

*Any combination of write or execute in this permission ensures the manager
 is defenseless.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Permission
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Risk
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

createClassLoader
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load classes into any protection domain
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

accessClassInPackage.sun
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access powerful restricted-access internal classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

setSecurityManager
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change the application's current security manager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReflectPermission(
\begin_inset Quotes eld
\end_inset

suppressAccessChecks
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow access to all class fields and methods as if they are public
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FilePermission(
\begin_inset Quotes eld
\end_inset

<<ALL FILES>>
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

write, execute
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write to or execute any file*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SecurityPermission(
\begin_inset Quotes eld
\end_inset

setPolicy
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modify the application's permissions at will
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Methodology
\begin_inset CommandInset label
LatexCommand label
name "sec:Methodology"

\end_inset


\end_layout

\begin_layout Standard
While Java exploits tend to follow only a few high-level operational patterns,
 the individual vulnerabilities they exploit are diverse both in their form
 and their location in the JRE.
 Given this complexity, we must understand how benign Java applications
 interact with the Java sandbox to design justifiable mitigations.
 The security manager is the means by which applications interact with the
 Java sandbox, thus we undertook an empirical analysis consisting of static,
 dynamic, and manual inspections of the open source Java application landscape
 to investigate benign interactions with the security manager.
 Our empirical analysis aimed to validate the following claims, roughly
 categorized by the strength of the mitigation that is possible if the claim
 is true:
\end_layout

\begin_layout Standard

\series bold
Weak Claim:
\series default
 
\shape italic
Benign applications do not disable the security manager.

\shape default
 If this claim is true, we can monitor applications to ensure they do not
 set the manager to null.
 This would prevent exploits that use current techniques, but attackers
 would easily shift to either weakening the policies enforced by the manager
 or replacing the current manager with one that never throws a 
\family typewriter
SecurityException
\family default
.
\end_layout

\begin_layout Standard

\series bold
Moderate Claim:
\series default
 
\shape italic
Benign applications do not weaken the security manager.

\shape default
 The moderate claim would lead to a stronger mitigation than the weak claim
 because it would prevent the manager and policy from being weakened, but
 the implementation of this mitigation would be potentially problematic
 because one would have to determine when a permission can be changed without
 creating a security vulnerability.
 This is difficult because it requires context a tool may not have.
 For example, if a permission to write to a file is replaced by a permission
 to write to a different file, how does a tool know if the new policy is
 weaker, stronger, or exactly as secure?
\end_layout

\begin_layout Standard

\series bold
Strong Claim:
\series default
 
\shape italic
Benign applications do not change the security manager or the enforced policy
 in any way if a self-protecting security manager has been set
\shape default
? The strongest mitigation is possible if this claim is true because it
 achieves a similar effect to the moderate mitigation while being substantially
 easier to implement: easily implemented mitigations are more likely to
 be implemented correctly.
\end_layout

\begin_layout Standard
We turned to the Qualitas Corpus (QC) 
\begin_inset CommandInset citation
LatexCommand cite
key "QualitasCorpus:APSEC:2010"

\end_inset

 and GitHub to form a dataset of applications that use the security manager.
 To sort out relevant applications in QC we performed a simple grep of each
 application's source code to find the keyword 
\shape italic
SecurityManager
\shape default
.
 Assuming any instance of the keyword was found, we included the application
 in our dataset.
 This reduced the overall set of applications to inspect from 112 to 29.
 This led to the inclusion of applications that had the keyword in comments
 or in unit tests that would not appear in production code, but these applicatio
ns were easily sorted out in later steps.
 We performed a similar process using the GitHub search feature configured
 to show source code, Java applications, and the most relevant results.
 At the time of our search, GitHub did not group results by project, thus
 we searched through the first 20 pages and found 17 unique projects that
 used the security manager to add to the dataset.
 While the page limit meant we only looked at a few hundred of the nearly
 100,000 files returned, we believe this procedure was sufficient to ensure
 our dataset is representative of how open source Java applications use
 the security manager.
\end_layout

\begin_layout Standard
We created static and dynamic analysis tools to further sort through the
 dataset before manually inspecting projects.
 Our static analysis is a plugin for FindBugs 
\begin_inset CommandInset citation
LatexCommand cite
key "hovemeyer_finding_2004"

\end_inset

 that uses a dataflow analysis to determine which initialized security managers
 may be set as System security manager by calling 
\family typewriter
System.setSecurityManager
\family default
().
 We created a dynamic analysis using JVMTI
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://docs.oracle.com/javase/7/docs/technotes/guides/jvmti/
\end_layout

\end_inset

.
 Our dynamic analysis set a modification watch on the 
\family typewriter
security
\family default
 field of Java's 
\family typewriter
System
\family default
 class.
 The security field is a private and static field that stores the 
\family typewriter
SecurityManager
\family default
 object that will be used by all JRE classes when making security policy
 decisions for the running Java application.
 The watch printed out the class name, source file name, and line of code
 where any write to the security field took place.
 The printed message contained a special notice if the security manager
 was being set to 
\family typewriter
null
\family default
.
 After running both of these tools on each project we were armed with the
 information required to further narrow our manual inspection efforts: which
 applications change the security manager, where they make the change, which
 changes are likely to invalidate a claim, and where SecurityManager objects
 are initialized.
\end_layout

\begin_layout Standard
We split the applications that used the security manager between two reviewers.
 The reviewers utilized a checklist to ensure that they consistently inspected
 each application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Summary-of-checklist"

\end_inset

 provides a summary of the items on our checklist; the full list provides
 details on carrying out each step.
 After performing a manual inspection, the reviewer ran the dynamic analysis
 on the application again, but this time with an emphasis on running executions
 that were known to exercise the security manager to ensure we didn't miss
 an important execution.
 Finally, the reviewer wrote a summary of how the application used the security
 manager with an emphasis on points that validate or invalidate each claim.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This table kind of sucks.
 Is there something better we can do?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Summary of checklist for manual reviews in the empirical analysis of security
 manager usage.
\begin_inset CommandInset label
LatexCommand label
name "tab:Summary-of-checklist"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify call sites for setSecurityManager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify references to SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify possible values for SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Research Questions and Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Research-Questions-and"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
How commonly are SM's used?
\end_layout

\begin_layout Plain Layout
Why do apps use the SM? - ZC: I like How better than Why
\end_layout

\begin_layout Plain Layout
What are the common mistakes made by apps using the SM?
\end_layout

\begin_layout Plain Layout
This section should cover the rules too (or maybe mitigations should do
 it up front?) -- call them privilege escalation and SecurityManager rules
 or change the names for the rules used in Mitigations section.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How do applications interact with the SecurityManager?
\end_layout

\begin_layout Standard
The first goal of our inspection of Java applications was to gain an understandi
ng of how Java applications interacted with the SecurityManager.
 To do so, applications were divided into categories based on how the applicatio
n interacted with the SecurityManager.
 The categories were: setting a SecurityManager and then changing the applicatio
n's SecurityManager during execution, setting a SecurityManager and not
 changing it during execution, interacting with a SecurityManager but never
 setting one, and not interacting with a SecurityManager at all.
 The first category, setting a SecurityManager and then chaning the SecurityMana
ger during execution, means that the applications either sets a different
 SecurityManager as the SecurityManager for the system, or the application
 alters the current SecurityManager for the system.
 Since this category was the most likely category to affect the validity
 of the claims, the applications in this category are further explained
 in later sections of this paper.
 The second category, setting a SecurityManager and not changing it during
 execution, meant that for each execution path, there was at most one place
 the application set a SecurityManager.
 This category supported our claims unless the SecurityManager was explicitly
 set to null, which would mean an attempt to disable a SecurityManager if
 one was set previously.
 Only one application in this category (JTimelag), explicilty set the SecurityMa
nager to null.
 This situation is discussed futher in the section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Reducing-Web-Application-Complexity"

\end_inset

.
 The third category, interacting with a SecurityManager but never setting
 one, consists of applications which contained code indicating the application
 was designed to work inside of a sandbox but never explicitly set up a
 sandbox in the application.
 The indicating code consists of adding extra permission checks if the applicati
on was inside of a sandbox, (**may want to explain doPrivileged here**)
 using doPrivileged calls to avoid checking the permissions of all classes
 on the stack, or ensuring that sections of the application would work within
 a sandbox using test cases.
 This category was further subdivided into applications which altered execution
 inside the main application (meaning extra permission check or calling
 doPrivileged) and applications which only contined test cases that interacted
 with the sandbox.
 The only contained test cases category also includes one application, system-ru
les, which was a utility for test cases.
 The final category, not interacting with a SecurityManager at all, means
 that the application either explicitly referenced the SecurityManager in
 comments but not in the source code or the application defined a class
 containing the name SecurityManger but the defined class did not extend
 java.lang.SecurityManager in any way.
\end_layout

\begin_layout Standard
After inspecting the 29 applications in the filtered Qualitas dataset, the
 applications were classified based on how they interacted with the SecurityMana
ger.
 (## probably should make this a table ##) Five of the applications set
 and then changed the SecurityManager as the program was running.
 Six of the applications contained code that set a SecurityManager, but
 did not change the SecurityManager after it was set.
 Thirteen applications contianed code that indicated they were designed
 to run inside a SecurityManager.
 Of those thirteen applications, ten contained code in the application that
 altered behavior when a SecurityManager was set.
 Three of those thirteen applications only interacted with a SecurityManager
 in test cases.
 The remaining five applications in the filtered Qualitas dataset were false
 positives.
\end_layout

\begin_layout Standard
The GitHub dataset also contained similar results.
 Three of the seventeen applications set and then changed the SecurityManager.
 One application set a SecurityManager and then did not change the set SecurityM
anager as the program was running.
 Eight applications contained code that indicated they were designed to
 work inside a sandbox if one was set.
 Of those eight applications, three altered execution if a sandbox was set
 while five of the eight applications only interacted with a sandbox in
 test cases.
 The other five applications were false positives.
\end_layout

\begin_layout Subsection
Non-security uses of the Sandbox
\end_layout

\begin_layout Standard
When investigating the applications in both of the datasets, the first surprisin
g discovery was that applications used in the sandbox in ways that were
 not designed to increase the security of the system.
 Specifically, the sandbox was used to enforce architectural constraints
 when interacting with other applications and to reduce development complexity
 in web application development.
\end_layout

\begin_layout Subsubsection
Enforcing Architectural Constraints 
\end_layout

\begin_layout Standard
Java applications commonly call 
\family typewriter
System.exit()
\family default
 if the application throws a non-recoverable error condition.
 However, this error handling method causes problems when applications work
 together, specifically when an application calls another application which
 will exit on an error.
 The problem with this interaction is that when the called application executes
 the 
\family typewriter
System.exit()
\family default
 line, the called application kills the calling application as well.
 The calling application is killed along with the called application because
 the execution of 
\family typewriter
System.exit()
\family default
 stops the virtual machine instance in which both applications are running.
\end_layout

\begin_layout Standard
In many cases, the ability for the called application to kill the calling
 application is an unintended side-effect.
 Thus the calling application needs to enforce the architectural constraint
 that called applications can not terminate the execution of the calling
 application.
 To enforce this architectural constraint, Java applications that call other
 applications set a SecurityManager that prevents 
\family typewriter
System.exit()
\family default
 calls.
 The new SecurityManager usually stops all calls to 
\family typewriter
System.exit()
\family default
 while the new SecurityManager is set and, if a SecurityManager was previously
 set, the new SecurityManager defers all other security checks to the previously
 set SecurityManager.
 When the calling application determines that the called application has
 finished, the calling application usually restores the previously set SecurityM
anager if one exists.
\end_layout

\begin_layout Standard
One example of an application preventing another application from calling
 
\family typewriter
System.exit()
\family default
 is Eclipse in Qualitas which calls Ant.
 When Ant reaches an unrecoverable error condition, Ant will call 
\family typewriter
System.exit()
\family default
 to terminate the compilation.
 However, Eclipse wants to continue executing and report an error to the
 user if Ant runs into a error condition.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}[b]{0.95
\backslash
linewidth} 
\end_layout

\begin_layout Plain Layout


\backslash
setbox0=
\backslash
vbox{%
\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=691,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(new AntSecurityManager(originalSM, Thread.currentThre
ad()));
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=703,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   getCurrentProject().executeTargets(targets); 
\backslash

\backslash
Note: Ant is executed on this line
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=703,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   finally {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=725,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   if (System.getSecurityManager() instanceof AntSecurityManager) { 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(originalSM); 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
hspace*{0.1cm}
\end_layout

\begin_layout Plain Layout


\backslash
fbox{
\backslash
box0} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Shown in the code above, on line 691 Eclipse sets a SecurityManager to prevent
 Ant from calling 
\family typewriter
System.exit()
\family default
.
 After performing some other checks, Ant is executed.
 Then after handling other error conditions, the original SecurityManager
 is restored.
\end_layout

\begin_layout Standard
Another example of enforcing the architectural constraint occurs in GJMan
 in the GitHub data set.
 The code references a blog page describing this problem and the implemented
 solution: http://www.jroller.com/ethdsy/entry/disabling_system_exit.
 The code reads 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt, firstnumber=703,frame=single,fonts
ize=
\backslash
scriptsize,framesep=2mm,xrightmargin=0.1cm]
\end_layout

\begin_layout Plain Layout

   public static void apply() { 
\end_layout

\begin_layout Plain Layout

     final SecurityManager securityManager = new SecurityManager() { 
\end_layout

\begin_layout Plain Layout

       public void checkPermission( Permission permission ) { 
\end_layout

\begin_layout Plain Layout

         if( permission.getName().startsWith("exitVM") ) { 
\end_layout

\begin_layout Plain Layout

           throw new Exception() ; 
\end_layout

\begin_layout Plain Layout

         } 
\end_layout

\begin_layout Plain Layout

       } 
\end_layout

\begin_layout Plain Layout

     } ; 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager( securityManager ) ; 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   public static void unapply() { 
\end_layout

\begin_layout Plain Layout

     System.setSecurityManager( null ) ; 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code contains the allow method which creates a SecurityManager that
 stops System.exit calls and the sets the created SecurityManager as the
 Sandbox for the Java Virtual Machine.
 The file also includes a method to remove the SecurityManager and removes
 the Sandbox from the Java Virtual Machine.
 While GJMan does not execute these lines explicitly, GJMan is written to
 be a library for other applications, so this file is likely used in other
 applications.
 
\end_layout

\begin_layout Standard
In total, we found 3 applications using a variation of this technique: Eclipse,
 GJMan, and AspectJ.
 While this technique is useful in applying architectural constraints, and
 probably the best architectural solution available in Java at the moment,
 this technique is likely to cause problems when applications desire the
 sandbox to also enforce security constraints.
 The reason this technique creates problems when trying to enforce security
 constraints is that the sandbox must be set in a state which it can be
 dynamically removed, otherwise the calling application could never terminate.
 By allowing the sandbox to be dynamically removed, the application must
 be carefully written to avoid allowing malicious code to turn off the sandbox.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Reducing-Web-Application-Complexity"

\end_inset

Reducing Complexity In Web Application Development
\end_layout

\begin_layout Standard
When Java web applications are run inside modern web browser, the application
 is sandboxed to protect the machine which hosts the browser.
 When the sandbox is set up, applications have to work inside the restrictions
 of the sandbox, meaning that applications are only approved to use the
 permissions allowed in the standard web browser sandbox.
 
\end_layout

\begin_layout Standard
To support applications which need to use permissions unavailable in the
 standard web browser sandbox, web browsers allow Java web applications
 to run without a sandbox after obtaining user approval.
 Developers, aware that users can turn off the sandbox, can develop applications
 in a way that require the sandbox to be explicitly turned off.
 Specifically, these applications ensure that the sandbox is off at the
 start of executing the web application.
 If a default sandbox is set, this check will cause the applications to
 crash with a SecurityException.
 Thus, the only way to run the applications are to turn off the sandbox.
\end_layout

\begin_layout Standard
In total we found two applications that were using this method: Eclipse
 in Qualitas and Timelag in Github.
 Since malicious applications are also known to turn off the sandbox, i.e.
 null the SecurityManager, it is important to carefully distinguish between
 a benign application which turns off the sandbox and a malicious application
 which turns off the sandbox.
 In the case where the application attempts to turn off the sandbox when
 starting the application and the application does not attempt to ensure
 the turn off attempt will succeed, it is determined that the application
 is trying to check if a sandbox is set and, if so, stop the application.
 On the other hand, applications which attempt to ensure that the sandbox
 is turned off, even when one is set, are likely malicious.
\end_layout

\begin_layout Standard
Eclipse contains the following code section in the file WebStartMain.java
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}[b]{0.95
\backslash
linewidth} 
\end_layout

\begin_layout Plain Layout


\backslash
setbox0=
\backslash
vbox{%
\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=22,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   /** 
\end_layout

\begin_layout Plain Layout

   * The launcher to start eclipse using webstart.
 To use this launcher, the client 
\end_layout

\begin_layout Plain Layout

   * must accept to give all security permissions.
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,fontsize=
\backslash
scriptsize,firstnumber=55,framesep=2mm,commandchars=
\backslash

\backslash

\backslash
{
\backslash
}]
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) 
\backslash
{ 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(null); 
\backslash
textbf{//TODO Hack so that when the classloader loading the fwk is created
 we don't have funny permissions.
 This should be revisited.
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
hspace*{0.1cm}
\end_layout

\begin_layout Plain Layout


\backslash
fbox{
\backslash
box0} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Eclipse comments show that the attempt to turn off the sandbox was done
 to avoid the permission issues caused by the default sandbox for Java Web
 Start.
 Timelag also contains the 
\family typewriter
System.setSecurityManager(null);
\family default
 line as the first line of its main function in the file JTimelag.java but
 does not contain any comments.
 So the motivation behind turning off the sandbox at the beginning of execution
 had to be inferred.
\end_layout

\begin_layout Subsection
Changing the SecurityManager for Security Purposes
\end_layout

\begin_layout Standard
In both datasets, we found applications that set a SecurityManager at one
 point a program and then either explicitly change or allow the user to
 change the currently set SecurityManager.
 Three appications allow the user to set and change the currently set SecurityMa
nager using provided methods (Batik, Eclipse, and Spring-modules) while
 three applications attempted to explicitly set and change the SecurityManager
 during execution (Ant, Freemind, and Netbeans (!! Not 100% sure about this
 one from what Tianyuan wrote, will need to investigate it later!!)).
 
\end_layout

\begin_layout Standard
For the applications that allowed the user to set and change the SecurityManager
, it seems the applications are attempting to provide the flexibility of
 the current Sandbox implementation in Java, with no strong security case
 for implementing the SecurityManager interactions this way.
 
\end_layout

\begin_layout Standard
For example, in Batik, the file ApplicationSecurityEnforcer contains the
 code segment:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbersep=-10pt,frame=single,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

156 public void enforceSecurity(boolean enforce){   
\end_layout

\begin_layout Plain Layout

157   SecurityManager sm = System.getSecurityManager();
\end_layout

\begin_layout Plain Layout

158
\end_layout

\begin_layout Plain Layout

159   if (sm != null && sm != lastSecurityManagerInstalled) {
\end_layout

\begin_layout Plain Layout

160     ...
\end_layout

\begin_layout Plain Layout

163     throw new SecurityException                 
\end_layout

\begin_layout Plain Layout

164      (Messages.getString(EXCEPTION_ALIEN_SECURITY_MANAGER));   
\end_layout

\begin_layout Plain Layout

165   }                  
\end_layout

\begin_layout Plain Layout

166   if (enforce) { 
\end_layout

\begin_layout Plain Layout

167     ...
\end_layout

\begin_layout Plain Layout

173    installSecurityManager();         
\end_layout

\begin_layout Plain Layout

174   } else {             
\end_layout

\begin_layout Plain Layout

175     if (sm != null) {                 
\end_layout

\begin_layout Plain Layout

176       System.setSecurityManager(null);
\end_layout

\begin_layout Plain Layout

177       lastSecurityManagerInstalled = null;             
\end_layout

\begin_layout Plain Layout

178      ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method was designed to allow users to add a SecurityManager to an applicati
on that uses the Batik library.
 The method first takes a boolean, then checks to make sure a Batik specific
 SecurityManager is not set.
 If a SecurityManager defined outside of Batik was not set, the application
 either sets a Batik SecurityManager, which refreshes the policy for the
 SecurityManager or sets the SecurityManager to null which turns off the
 sandbox.
 This methods use was demonstrated in some of the examples provided in the
 application download from the Batik website.
 Two of the downloads provide ways to set a SecurityManager at start up,
 the squiggle browser demo and the rasterizer demo.
 While the squiggle browser demo sets a SecurityManager and never changes
 it, the rasterizer demo can be set to call enforceSecurity with a true
 arguement the first time and a false argument the second time, cause the
 application to set a SecurityManager and then remove it at the end of the
 demo.
 While this was an interesting occurance, there seemed to be no valid reason,
 other than showing off the capabilties for the library, to turn the SecurityMan
ager off at the end of the execution.
\end_layout

\begin_layout Standard
Only in the case where an application can not be reset and the application
 cannot predict future required permissions, which we believe to be rare,
 applications would need the ability to dynmically refresh the sandbox.
 In all other cases, the ability to dynamically adjust the SecurityManager
 and the sandbox's policy is not required.
 As long as the required permission can be predicted before the application
 is running, class loaders with defined permission sets can assign the permissio
n to any newly loaded Java classes, thus allowing applications to provide
 permissions to the classes that require them.
 (&& I don't like this section's wording - I should ask Michael for input
 on how to word it correctly).
\end_layout

\begin_layout Standard
As mentioned earlier, Ant, Freemind, and Netbeans explicitly set and then
 change the current SecurityManager during runtime.
 Ant wants to allow the user the capability to execute Java applications
 during a build under a user specified set of permissions.
 To provide this capability, Ant sets the SecurityManager before executing
 the Java application and then removes the SecurityManager after the application
 has finished executing.
 Netbeans also takes a similar approach ( && need to check this &&).
\end_layout

\begin_layout Standard
Freemind also tried to solve a similar problem, but demonstrates the difficulty
 of currectly implementing this solution.
 Freemind is a diagram drawing tool that allows users to execute Groovy
 scripts on the current drawing.
 The developers of Freemind implemented the sandbox so that it would turn
 on before executing a user run script and would turn off after the script
 finished executing.
 The security goals of the Freemind sandbox was to stop malicious scripts
 from creating files, executing programs on the machine, and creating network
 sockets to establish connections with outside entities.
 Unfortunately, in the version we analyzed (*** should put version somewhere
 ***), these goals were not achieved.
 By implementing the SecurityManager in the old SecurityManager style, explicitl
y removing privileges, multiple dangerous permissions were left, such as
 the ability to alter private variables with reflection.
 This privilege made it trivial to remove the currently set SecurityManager
 inside a Groovy script, thus turning off the sandbox, and allowing the
 script to create files.
 The authors submitted a sample exploit to the Freemind development group
 and made recommendations on how to improve the security of the Freemind
 sandbox.
 (*** also should probably mention something about the SecurityManager indirecti
on ***).
\end_layout

\begin_layout Standard
As with the applications that allow setting setting and chaning the SecurityMana
ger, we believe the applications which set and change the SecurityManager
 explicitly can execute correctly using a static SecurityManager with class
 loaders which limit the permissions of the restricted code sections.
 
\end_layout

\begin_layout Standard
The one application that did not fall into either of these categories was
 WildflySecurityManager.
 The WildfiySecurityManager allows turning off the permission checks for
 classes which have been granted the DO_UNCHECKED_PERMISSION.
 However, this method of permission checks seems to be the same as assiging
 the privileged classes the AllPermissions and then executing doPrivileged
 on the privileged actions that the privileged class needs to do.
\end_layout

\begin_layout Subsection
Rules
\end_layout

\begin_layout Standard
Based on the result of our investigation, it was determined that we could
 restrict applications in two ways to improve security, preventing applications
 from loading privileged classes when the loading class did not have the
 required itself and preventing changing the SecurityManager when a 
\emph on
self-protecting
\emph default
 SecurityManager is set.
 These restrictions were classified as rules, the privilege escalation rule
 and the SecurityManager rule.
\end_layout

\begin_layout Subsubsection
Privilege Escalation Rule
\end_layout

\begin_layout Standard
The privilege escalation rule states that a class may not load a more permissive
 class if a SecurityManager is set for the application.
 This means that the loading classes permissions has to be less restrictive
 or the same level of restriction as the loaded class.
 This rule is based around the fact that many exploits load a class with
 more privileges than the calling class to break out of the sandbox.
 
\end_layout

\begin_layout Standard
If all classes in the Java Virtual Machine (JVM) instance were loaded at
 the start of an application, this rule would be without exceptions.
 However, the JVM loads certain classes on demand, and some of the JVM classes
 have the full privileges.
 Thus the rule has to make an excpetion for these classes.
 Specifically, the rule makes exceptions for classes returned by the call
 
\family typewriter
java.security.Security.getProperty(
\begin_inset Quotes eld
\end_inset

package.access
\begin_inset Quotes erd
\end_inset

);.
 
\end_layout

\begin_layout Subsubsection
SecurityManager Rule
\end_layout

\begin_layout Standard
The SecurityManager Rule states that a SecurityManager cannot change if
 a 
\emph on
self-protecting
\emph default
 SecurityManager has been set by the application.
 By setting a 
\emph on
self-protecting 
\emph default
SecurityManager, the application is removing ability of changing or removing
 the sandbox.
 Thus, the rule is violated if something in the application causes a change
 in the sandbox's setting, which is what many exploits try to ensure will
 happen.
 (&& probably should tie these to the hypotheses somehow but need to read
 the paper to understand how to do that.&&)
\end_layout

\begin_layout Section
Mitigations
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Methodology"

\end_inset

 we discussed (1) three claims that would lead to Java exploit mitigations
 if validated and (2) how we went about validating them.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Research-Questions-and"

\end_inset

 we discussed additional research questions we answered while successfully
 validating the strong claim and the overall results of our empirical analysis
 of the open source Java landscape.
 The results included two backwards-compatible rules that can be enforced
 to stop current exploits.
 In this section we discuss the implementation and evaluation of a tool
 that implements the privilege escalation and SecurityManager rules.
 We evaluated this tool in collaboration with a large aerospace company
 that is currently working on deploying the tool to workstations that belong
 to employees that are often the subject of targeted attacks.
 
\end_layout

\begin_layout Subsection
Implementation Using JVMTI
\end_layout

\begin_layout Standard
Prior work has made an effort to prevent exploits in the native libraries
 used by language runtimes such as Java's 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010,li_quarantine:_2011,siefers_robusta:_2010,sun_jvm-portable_2012"

\end_inset

, and the machine learning community has put some effort into detecting
 exploits delivered via drive-by-downloads using Java applets and similar
 technologies 
\begin_inset CommandInset citation
LatexCommand cite
key "cova_detection_2010,ford_analyzing_2009,helmer_anomalous_2001,schlumberger_jarhead_2012"

\end_inset

.
 We implemented a tool in JVMTI to pro-actively stop exploits written directly
 in the Java programming language to exploit vulnerable Java code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Our tool, Java Sandbox Fortifier, is open source and hosted on GitHub at
 https://github.com/SecurityManagerCodeBase/JavaSandboxFortifier.
 REVIEWERS: INSPECTING THIS GITHUB PROJECT MAY REVEAL THE AUTHORS' IDENTITIES.
\end_layout

\end_inset

.
 In particular, our tool focuses on fortifying the Java sandbox to reduce
 the probability that the sandbox will be successfully bypassed in an attack.
\end_layout

\begin_layout Standard
JVMTI is a native interface used to access JVM operations that are intended
 to be used to create analysis tools such as profilers, debuggers, monitors,
 and thread analysers.
 Tools that use JVMTI are called agents and are attached to a running Java
 application at some configuration specific point in the application's lifecycle.
 The interface allows an agent to set capabilities that enable the tool
 to intercept events such as class and thread creation, field access and
 modifications, breakpoints, and much more.
 After acquiring the necessary capabilities, a JVMTI agent registers callbacks
 for the events they want to receive.
 JVMTI provides a rich API, hooks for instrumenting the bytecode of loaded
 classes, and access to the JNI, all of which can be used to perform nearly
 any operation on classes, threads, etc.
 that a tool may want to perform at the time when an event occurs.
 Our agent must intercept three events to enforce the privilege escalation
 and SecurityManager rules: 
\family typewriter
ClassPrepare
\family default
, 
\family typewriter
FieldAccess
\family default
, and 
\family typewriter
FieldModification
\family default
.
 Enforcement of these rules is discussed in detail in subsections below.
\end_layout

\begin_layout Standard
Our agent was written in C++.
 524 lines of code were required to enforce the privilege escalation rule
 while 377 lines of code were required for the SecurityManager rule when
 counted using the Linux tool 
\family typewriter
wc
\family default
.
 This code constitutes the attack surface for our tool because a malicious
 class could potentially craft information such as class, field, or method
 names to exploit an issue in the rule enforcement code when the information
 is passed to the appropriate callback.
 The risk here is greatly reduced both by the fact that there is little
 attack surface to inspect and due to the previously cited work that can
 be applied to our tool.
 For example, the software-based fault isolation subset of Robusta 
\begin_inset CommandInset citation
LatexCommand cite
key "siefers_robusta:_2010"

\end_inset

 can be applied to our tool to isolate the effects of an exploit.
 Using a security kernel for Java similar to Cappo's for Python 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010"

\end_inset

, our tool could be isolated to its own security layer with access only
 to the information it gets from JVMTI.
 We did not attempt to apply these solutions because the required tools
 and code are not publicly available, which would make it difficult, if
 not impossible, for most people to adopt our tool.
\end_layout

\begin_layout Standard
Our agent may be configured to run in enforce or monitor mode.
 In enforce mode a violation of either rule causes the agent to log the
 offending behavior and terminate the JVM to which the agent is attached.
 In monitor mode the agent logs the offending behavior but leaves the JVM's
 execution of the application untouched.
 In either case, a popup is shown to the user to let them know why their
 Java application was terminated when the agent has been configured to show
 popups (this was made configurable to prevent popups on headless servers).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-popup-from"

\end_inset

 shows an example of a popup displayed after an exploit was caught breaking
 the privilege escalation rule.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename rule_violation_popup.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A popup from our agent after it caught an exploit breaking the privilege
 escalation rule.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-popup-from"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Enforcing the Privilege Escalation Rule
\end_layout

\begin_layout Standard
The privilege escalation rule is enforced by ensuring that, after a self-protect
ing security manager has been set, classes do not load or cause the loading
 of more privileged classes unless the privileged class is in a restricted-acces
s package.
 
\shape italic
Restricted-access packages
\shape default
 are packages that are public but not intended to be directly used by typical
 Java applications; they are meant for internal JRE use only.
 These packages are listed in the 
\family typewriter
package.access
\family default
 property in the 
\family typewriter
java.security.Security
\family default
 class.
 There are two ways to directly access packages listed in this property:
 (1) exploit a vulnerability in a class that can access them or (2) allow
 access via the 
\family typewriter
accessClassInPackage
\family default
 permission.
 The latter option would ensure the security manager is defenseless, thus
 the application would not be protected by the agent (see table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:defenseless-permissions"

\end_inset

).
\end_layout

\begin_layout Standard
We must allow a class to indirectly load a class in a restricted-access
 package because classes in these packages are often used by JRE classes
 that an application is allowed to use.
 For example, many of the classes in the 
\family typewriter
java.lang.reflect
\family default
 package are backed by classes in the 
\family typewriter
sun
\family default
 package, the latter of which is a restricted-access package that contains
 the internal implementations for many Java features.
\end_layout

\begin_layout Standard
To enforce this rule, our agent registers for the 
\family typewriter
ClassPrepare
\family default
 event, which allows it to inspect a class after it is fully loaded but
 just before any of its code is executed.
 Assuming the loaded class is not in a restricted-access package, the agent
 inspects the stack frame to determine which class caused the new class
 to be loaded.
 The agent must get the protection domains for both classes, but this can
 not be done by calling the necessary Java methods
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
Class.getProtectionDomain()
\end_layout

\end_inset

 via the JNI from the agent because the Java calls will be performed with
 the same permissions as the application the agent is attached to.
 Most applications where this operation is relevant (i.e.
 those that have a self-protecting manager) do not have the necessary permission
 to get a protection domain
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
RuntimePermission(
\begin_inset Quotes eld
\end_inset

getProtectionDomain
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 because it would allow a malicious class to probe the policy to determine
 which, if any, malicious operations it can perform.
 Due to the fact that JVMTI agents are loaded into the JRE as a shared-library,
 we instead load libjvm.so (jvm.dll on Microsoft Windows) to call JVM functions
 without security checks.
 Our agent leverages this ability to call the 
\family typewriter
GetProtectionDomain
\family default
 JVM function to get the protection domains.
 
\end_layout

\begin_layout Standard
With both protection domains, the implementation of the agent as of the
 time of this writing simply checks to see if the loaded class's protection
 domain has 
\family typewriter
AllPermissions
\family default
 while the class that caused the loading doesn't.
 If the latter is true, the privilege escalation rule has been violated.
 This specific check was used because it is fast, simple, and all privileged
 classes allow 
\family typewriter
AllPermissions
\family default
 under known circumstances.
 It would be easy to update this check to instead ensure that every permission
 in the loaded class's protection domain is also in the other protection
 domain to handle cases we are currently not aware of.
\end_layout

\begin_layout Subsubsection*
Enforcing the SecurityManager Rule
\end_layout

\begin_layout Standard
The SecurityManager rule is enforced by monitoring every read from and write
 to the 
\family typewriter
security
\family default
 field of the 
\family typewriter
System
\family default
 class; this field stores the security manager that is used by protected
 code.
 The agent implements the read and write monitors by respectively registering
 
\family typewriter
FieldAccess and FieldModification
\family default
 events for the field.
 Typically the field, which is private and static, is accessed via 
\family typewriter
System.getSecurityManager()
\family default
 and modified using 
\family typewriter
System.setSecurityManager()
\family default
, but we must monitor the field instead of instrumenting these methods to
 detect type confusion attacks, as discussed later in this section.
 
\end_layout

\begin_layout Standard
The agent stores a shadow copy of the application's most recent security
 manager to have a trusted copy of the manager that can be used to check
 for rule violations.
 In a typical deployment, the agent is loaded by a JVM before the hosted
 Java application's code has begun executing.
 Even in the typical case, when a security manager is set on the command
 line that runs the application, the initial security manager would not
 be caught by the modification event because the write happens before the
 agent is loaded.
 To solve this problem, the shadow copy is first initialized by calling
 
\family typewriter
System.getSecurityManager()
\family default
 when the agent is loaded by a JVM.
 After this point, the shadow copy is only updated by the modification event,
 which receives the new manager as a parameter from JVMTI whenever the event
 is triggered.
\end_layout

\begin_layout Standard
Modification events are used to detect any change to a self-protecting security
 manager.
 When the field is written, the agent checks the shadow copy of the manager.
 Assuming the shadow copy is 
\family typewriter
null
\family default
, the agent knows the manager is being set for the first time and checks
 to see if the new manager is self-protecting.
 If the manager is self-protecting the agent simply updates the shadow copy,
 otherwise the agent will also drop into monitor mode when enforce mode
 is configured because the rules cannot be enforced for applications that
 use defenseless managers.
 We cannot enforce the rules in the presence of a defenseless security manager
 because enforcement may break the function of benign applications that
 utilize a defenseless manager, as in several examples in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Research-Questions-and"

\end_inset

.
 In any case, future modifications are logged as a violation of the rule
 and trigger the operation relevant to the agents current mode as discussed
 above.
\end_layout

\begin_layout Standard
Access events are used to detect type confusion attacks against the manager.
 The modification event we register will not be triggered when the manager
 is changed due to a type confusion attack.
 When a type confusion attack is used to masquerade a malicious class as
 the 
\family typewriter
System
\family default
 class, the malicious copy will have different internal JVM identifiers
 for the field that stores the manager, the class itself, and its methods
 even though writing to the field in one version of the class updates the
 same field in the other version.
 The modification and access events are registered for specific field and
 class identifiers, thus the events are not triggered for operations on
 the malicious version.
 We leverage the mismatch this causes between the set security manager and
 our shadow copy in the access event by checking to see if the manager that
 was just read has the same internal JVM reference as our shadow copy.
 When the two references do not match, the manager has been changed as the
 result of a malicious class masquerading as the 
\family typewriter
System
\family default
 class.
 Type confusion attacks may also be used to masquerade a class as a privileged
 class loader to elevate the privileges of a payload class that disables
 the manager, but this scenario is detected by the modification event.
\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Discuss the different deployment options to work around the slowdown
\end_layout

\begin_layout Plain Layout
Explicitly mention the default configuration here! (e.g.
 SM rule off)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
ZC: At the moment, I'm not happy enough with the performance results to
 write this section.
 I'll come back to it when I have better numbers.
 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Effectiveness at Fortifying the Sandbox
\end_layout

\begin_layout Standard
We performed an experiment to evaluate how effective our agent is at blocking
 exploits that disable the sandbox.
 In our experiment, we ran Java 7 exploits for the browser from Metasploit
 4.10.0
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.metasploit.com/
\end_layout

\end_inset

 on 64-bit Windows 7 against the initial release of version 7 of the JRE.
 This version of Metasploit contains twelve applets that are intended to
 exploit JRE 7 or earlier, but two did not successfully run due to Java
 exceptions we did not debug.
 Metasploit contains many Java exploits outside of the subset we used, but
 the excluded exploits either only work against long obsolete versions of
 the JRE or are not well positioned to be used in drive-by-downloads.
 
\end_layout

\begin_layout Standard
We ran the ten exploits in our set under the following conditions: without
 the agent, with the agent but only enforcing the privilege escalation rule,
 and while enforcing both rules.
 We ran these conditions to respectively: establish that the exploits succeed
 against our JRE, test how effective the privilege escalation rule is without
 the security manager rule, and evaluate how effective the agent is in the
 strictest configuration currently available.
 Running the privilege escalation rule alone is interesting because it provides
 some indication of how effective this rule is at stopping applet exploits
 in general, outside of simply fortifying the security manager.
 Overall, all ten of the exploits succeed against our JRE without the agent,
 four were stopped by the privilege escalation rule, and all ten were stopped
 when both rules were enforced.
 The exploits that were not stopped by the privilege escalation rule were
 either type confusion exploits or exploits that did not need to elevate
 the privileges of the payload class.
 The payload class does not need elevated privileges when it can directly
 access a privileged class to exploit.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Exploit-experiment-summary"

\end_inset

 summarizes our results using the specific CVE's each exploit targeted.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A summary of CVE's we ran exploits for and how effective the agent was at
 stopping them in the following conditions: (1) just the privilege escalation
 rule enforced and (2) both rules enforced.
 Blocked exploits were stopped by the agent before the malicious payload
 could run, but fully executed exploits were able to complete their malicious
 operations.
\begin_inset CommandInset label
LatexCommand label
name "tab:Exploit-experiment-summary"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Exploited CVE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Privilege Escalation Enforced
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Both Rules Enforced
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2011-3544
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012-0507
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012-4681
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2012-5076
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-0422
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-0431
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-1488
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-2423
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-2460
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2013-2465
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fully Executed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blocked
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
Unfortunately, neither of these rules will able to stop 100% off all Java
 exploits.
 Both rules are unable to catch exploits which are able to escape the sandbox
 without violating the constraints the rules impose.
 While the privilege escalation rule is able to stop many of the most common
 Java exploits (40% of tested exploits), the rule still does not catch a
 significant portion of the exploits.
 The SecurityManager rule is also not able to catch all exploits.
 While the SecurityManager rule was able to catch all tested exploits, Java
 makes it possible to write exploits that do not turn off the SecurityManager
 but are still able to cause significant damage.
 While the authors beleive the rules created in this study provide a substanial
 improvement over the current sandbox implementation, the authors also believe
 that future work will be able to build upon the results of this study to
 create improved mitigation techiques.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
