#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
\usepackage{fancyvrb}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 1
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Fortifying the Java Sandbox
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Related science:
\end_layout

\begin_layout Plain Layout
1.
 Most Dangerous Code in the World
\end_layout

\begin_layout Plain Layout
2.
 Zero Day Vulnerabilities (Before We Knew It)
\end_layout

\begin_layout Plain Layout
3.
 Password Manager insecurity paper (from Sep 2014)
\end_layout

\begin_layout Plain Layout
Related science probably makes sense to go right before the flag post paragraph.
\end_layout

\begin_layout Plain Layout
This section should define JVMTI so that we can use it everywhere else but
 don't explain much about what it is here -- shouldn't be hard to do (cite
 the docs when doing it)
\end_layout

\begin_layout Plain Layout
Needs to mention JVM to define acronym.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Java sandbox was designed to enable the safe execution of code from
 untrusted sources.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sandbox-high-level-summary"

\end_inset

 summarizes the components of the sandbox that are relevant to this work.
 Essentially, when a class loader loads a class from some location (e.g.,
 network, filesystem, etc.) the class is assigned a code source.
 The code source is used to indicate the origin of the code while it is
 loaded in the JRE and to associate the class with a protection domain.
 Protection domains segment classes into different groups that are assigned
 a security policy.
 Each domain imposes one policy on the classes it contains where a policy
 includes a set of permissions that grant the contained classes the ability
 to perform operations such as writing to the filesystem, accessing the
 network, using certain reflection features, etc.
 (see a more complete list at 
\begin_inset CommandInset citation
LatexCommand cite
key "_permissions_2014"

\end_inset

).
 Each JRE contains a default policy configuration that grants applications
 from the local filesystem all permissions and applets from the web a strict
 set of permissions that prevent them from performing malicious operations
 on the host system.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename sandbox_overview.png
	scale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A high-level summary of the Java sandbox as it pertains to this work.
\begin_inset CommandInset label
LatexCommand label
name "fig:Sandbox-high-level-summary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To enforce the security policy, a security manager must be set (typically
 by calling
\family typewriter
 System.setSecurityManager(new SecurityManger())
\family default
).
 The security manager acts as the gateway to policy enforcement in the Java
 sandbox.
 Whenever Java code wants to ensure a caller has the correct permissions
 to execute protected code, the callee must query the security manager.
 For example, if an application attempts to use a JRE class to write to
 a file (e.g Java.io.FileOutputStream), the JRE class will ensure that the
 caller has permission to write to the file before performing the write.
 When such a query is initiated, the security manager walks the stack frames
 for the current calling context to ensure every class in the context has
 the correct permissions or a privileged caller has marked the context as
 privileged.
 If the context is not marked as privileged and even one class in the stack
 frame does not have the correct permissions, the manager will throw a SecurityE
xception.
 Stack-based access control is discussed in more detail in 
\begin_inset CommandInset citation
LatexCommand cite
key "banerjee_stack-based_2005,besson_stack_2004,d._s._wallach_understanding_1998,erlingsson_irm_2000,fournet_stack_2002,pistoia_beyond_2007,zhao_type_2005"

\end_inset

.
 Typically a security manager is automatically set by the JRE when a class
 is loaded using class loaders for sources that are nearly always untrusted
 such as applets.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
JSS: Show the example payload from your slides here.
\end_layout

\end_inset

Malicious drive-by downloads using Java applets as the vector were widely
 reported between 2011 and 2013.
 While the security manager should prevent applets from performing operations
 that are useful to a malicious actor, vulnerabilities in the JRE were leveraged
 to set the manager to null.
 The latter operation effectively disables the Java sandbox, thus allowing
 previously constrained classes to perform any operation that the JRE can
 perform.
 These vulnerabilities tend to fall into one of two categories: those that
 exploit a type confusion vulnerability to set the security manager to null
 and those that exploit a confused deputy vulnerability 
\begin_inset CommandInset citation
LatexCommand cite
key "hardy_confused_1988"

\end_inset

 in a privileged JRE class to null the security manager.

\series bold
 
\end_layout

\begin_layout Standard
In the case of type confusion a vulnerability is exploited to break type
 safety, thus allowing the attacker to craft an object that can perform
 operations as if it is an instance of a class of a different type or as
 if it is an already existing object of a different type.
 For example, attackers will craft objects that either (1) point to the
 System class to cause any operation they perform to happen on the real
 System class, thus allowing them to directly alter the field where the
 security manager is stored or (2) act as if they have the same type as
 a privileged class loader to load a payload class with all permissions
 (see CVE-2012-0507 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_0507"

\end_inset

).
 In the case of a confused deputy, the exploit often attacks a privileged
 class that is accessible by any class to obtain an instance of a vulnerable
 privileged class that is only accessible to other privileged classes.
 The restricted-access class is targeted because it contains a vulnerability
 that can be leveraged to execute privileged code, typically to null the
 security manager (see CVE-2012-4681 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_4681"

\end_inset

).
 While it is possible for an accessible privileged class to contain a vulnerabil
ity that will allow an attacker to null the manager more directly, these
 classes are typically implemented more carefully to avoid these types of
 issues.
\end_layout

\begin_layout Standard
Many of the recent vulnerabilities would not have been introduced if the
 JRE was developed while strictly following 
\begin_inset Quotes eld
\end_inset

The CERT Oracle Secure Coding Standard for Java
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "long_cert_2011"

\end_inset

.
 For example, Svoboda 
\begin_inset CommandInset citation
LatexCommand cite
key "svoboda_anatomy_blog_2013,svoboda_anatomy_2014"

\end_inset

 pointed out that CVE-2012-0507 and CVE-2012-4681 were caused by violating
 a total of six different secure coding rules and four guidelines.
 In the typical case, following just one or two of the broken rules and
 guidelines would have prevented a serious exploit.
 In the rest of this paper we concern ourselves with ways to fortify the
 Java sandbox without breaking backwards compatibility and not with the
 specifics of particular exploits.
\end_layout

\begin_layout Standard
For the purpose of fortifying the sandbox, we distinguish between self-protectin
g and defenseless security managers.
 A 
\shape italic
self-protecting
\shape default
 security manager enforces a policy that prevents encapsulated classes from
 changing the manager or the policy it enforces.
 In contrast, a 
\shape italic
defenseless
\shape default
 security manager allows encapsulated classes to change the manager or the
 enforced policy.
 A defenseless manager does little to improve the security posture of the
 encapsulated Java application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:defenseless-permissions"

\end_inset

 summarizes the set of permissions used to distinguish between self-protecting
 and defenseless security managers.
 A manager enforcing a policy that contains even one of the listed permissions
 is considered to be defenseless.
 A subset of the permissions in this list were identified in 
\begin_inset CommandInset citation
LatexCommand cite
key "security_explorations_2012"

\end_inset

.
 
\begin_inset Note Comment
status open

\begin_layout Plain Layout
JSS: Give a definition of a descriptive definition of self-protecting and
 defenseless security managers earlier.
 Leave this operational defintion here.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Permission
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Risk
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

createClassLoader
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load classes into any protection domain
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

accessClassInPackage.sun
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access powerful restricted-access internal classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(
\begin_inset Quotes eld
\end_inset

setSecurityManager
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change the application's current security manager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReflectPermission(
\begin_inset Quotes eld
\end_inset

suppressAccessChecks
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow access to all class fields and methods as if they are public
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FilePermission(
\begin_inset Quotes eld
\end_inset

<<ALL FILES>>
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

write, execute
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write to or execute any file*
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SecurityPermission(
\begin_inset Quotes eld
\end_inset

setPolicy
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modify the application's permissions at will
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A security manager enforcing a policy that contains any permission in this
 list is defenseless.
\begin_inset CommandInset label
LatexCommand label
name "tab:defenseless-permissions"

\end_inset


\begin_inset Newline newline
\end_inset

*Any combination of write or execute in this permission ensures the manager
 is defenseless.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Methodology
\begin_inset CommandInset label
LatexCommand label
name "sec:Methodology"

\end_inset


\end_layout

\begin_layout Standard
While Java exploits tend to follow one of several high-level patterns, the
 individual vulnerabilities they exploit are diverse in their form and their
 location in the JRE.
 Given this complexity, we must understand how benign Java applications
 interact with the Java sandbox to design justifiable mitigations.
 The security manager is the means by which applications interact with the
 Java sandbox, thus we undertook an empirical analysis consisting of static,
 dynamic, and manual inspections of the open source Java application landscape
 to investigate benign uses of the security manager.
 Our empirical analysis aimed to validate the following claims, roughly
 categorized by the strength of the mitigation that is possible if the claim
 is true:
\end_layout

\begin_layout Standard

\series bold
Weak Claim:
\series default
 
\shape italic
Benign applications do not disable the security manager.

\shape default
 If this claim is true, we can monitor applications to ensure they do not
 set the manager to null.
 This would prevent exploits as they are currently written, but it would
 be simple for attackers to shift to weakening the policies enforced by
 the manager or to replace the current manager with one that never throws
 a 
\family typewriter
SecurityException
\family default
.
\end_layout

\begin_layout Standard

\series bold
Moderate Claim:
\series default
 
\shape italic
Benign applications do not weaken the security manager by allowing previously
 disallowed operations.

\shape default
 The moderate claim would lead to a stronger mitigation than the weak claims
 because it would prevent the manager and policy from being weakened, but
 the implementation of this mitigation would be potentially problematic
 because one would have to determine when a permission can be changed without
 creating a security vulnerability.
 This is difficult because it requires context a tool may not have.
 For example, if a permission to write to a file is replaced by a permission
 to write to a different file, how does a tool know if the new policy is
 weaker, stronger, or exactly as secure?
\end_layout

\begin_layout Standard

\series bold
Strong Claim:
\series default
 
\shape italic
Benign applications do not change the security manager or the enforced policy
 in any way if a self-protecting security manager has been set
\shape default
? The strongest mitigation is possible if the strong claim is true because
 it achieves a similar effect to the moderate mitigation while being substantial
ly easier to implement.
\end_layout

\begin_layout Standard
We turned to the Qualitas Corpus (QC) 
\begin_inset CommandInset citation
LatexCommand cite
key "QualitasCorpus:APSEC:2010"

\end_inset

 and GitHub to form a dataset of applications that use the security manager.
 To sort out relevant applications in QC we performed a simple grep of each
 application's source code to find the keyword 
\shape italic
SecurityManager
\shape default
.
 Assuming any instance of the keyword was found, we included the application
 in our dataset.
 This reduced the overall set of applications to inspect from 112 to 29.
 While this led to the inclusion of applications that had the keyword in
 comments or in unit tests that would not appear in production code, these
 applications were easily sorted out in later steps.
 We performed a similar process using the GitHub search feature configured
 to show source code, Java applications, and the most relevant results.
 At the time of our search, GitHub did not group results by project, thus
 we searched through the first 20 pages and found 17 unique projects that
 used the security manager to add to the dataset.
 While the page limit meant we only looked at a few hundred of the nearly
 100,000 files returned, we believe this procedure was sufficient to ensure
 our dataset is representative of how open source Java applications use
 the security manager.
\end_layout

\begin_layout Standard
We created static and dynamic analysis tools to further sort through the
 dataset before manually inspecting projects.
 Our static analysis is a plugin for FindBugs 
\begin_inset CommandInset citation
LatexCommand cite
key "hovemeyer_finding_2004"

\end_inset

 that uses a dataflow analysis to determine what initialized security managers
 may be set as System security manager by calling 
\family typewriter
System.setSecurityManager
\family default
.
 We created a dynamic analysis using JVMTI
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://docs.oracle.com/javase/7/docs/technotes/guides/jvmti/
\end_layout

\end_inset

.
 Our dynamic analysis set a modification watch on the 
\family typewriter
security
\family default
 field of Java's System class.
 The security field is a private and static field that stores the SecurityManage
r object that will be used by all JRE classes when making security policy
 decisions for the running Java application.
 The watch printed out the class name, source file name, and line of code
 where any write to the security field took place.
 The printed message contained a special notice if the security manager
 was being set to 
\family typewriter
null
\family default
.
 After running both of these tools on each project we were armed with the
 information required to further narrow our manual inspection efforts: which
 applications change the security manager, where they make the change, and
 where SecurityManager objects are initialized.
\end_layout

\begin_layout Standard
We split the applications that used the security manager between two reviewers.
 The reviewers utilized a checklist to ensure that they consistently inspected
 each application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Summary-of-checklist"

\end_inset

 provides a summary of the items on our checklist; the full list provides
 details on carrying out each step.
 After performing a manual inspection, the reviewer ran the dynamic analysis
 on the application again, but this time with an emphasis on running executions
 that were known to exercise the security manager to ensure we didn't miss
 an important execution.
 Finally, the reviewer wrote a summary of how the application used the security
 manager with an emphasis on points that support or reject each claim.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This table kind of sucks.
 Is there something better we can do?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Summary of checklist for manual reviews in the empirical analysis of security
 manager usage.
\begin_inset CommandInset label
LatexCommand label
name "tab:Summary-of-checklist"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify call sites for setSecurityManager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify references to SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify possible values for SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Research Questions and Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Research-Questions-and"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
% ran our transformations to remove the reported integer vulnerabilities
 from 5 open source programs: The program transformations were manually
 applied to remove the root cause if integer vulnerabilities (Section 
\backslash
ref{sssec:realprog}).
 We then 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
How commonly are SM's used?
\end_layout

\begin_layout Plain Layout
Why do apps use the SM? - ZC: I like How better than Why
\end_layout

\begin_layout Plain Layout
What are the common mistakes made by apps using the SM?
\end_layout

\begin_layout Plain Layout
This section should cover the rules too (or maybe mitigations should do
 it up front?) -- call them privilege escalation and SecurityManager rules
 or change the names for the rules used in Mitigations section
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How do applications interact with the SecurityManager?
\end_layout

\begin_layout Standard
The first goal of our inspection of Java applications was to gain an understandi
ng of how Java applications interacted with the SecurityManager.
 To do so, applications were divided into categories based on how the applicatio
n interacted with the SecurityManager.
 The categories were: setting a SecurityManager and then changing the applicatio
n's SecurityManager during execution, setting a SecurityManager and not
 changing it during execution, interacting with a SecurityManager but never
 setting one, and not interacting with a SecurityManager at all.
 The first category, setting a SecurityManager and then chaning the SecurityMana
ger during execution, means that the applications either sets a different
 SecurityManager as the SecurityManager for the system, or the application
 alters the current SecurityManager for the system.
 Since this category was the most likely category to affect the validity
 of the claims, the applications in this category are further explained
 in later sections of this paper.
 The second category, setting a SecurityManager and not changing it during
 execution, meant that for each execution path, there was at most one place
 the application set a SecurityManager.
 This category supported our claims unless the SecurityManager was explicitly
 set to null, which would mean an attempt to disable a SecurityManager if
 one was set previously.
 Only one application in this category (JTimelag), explicilty set the SecurityMa
nager to null.
 This situation is discussed futher in the section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Reducing-Web-Application-Complexity"

\end_inset

.
 The third category, interacting with a SecurityManager but never setting
 one, consists of applications which contained code indicating the application
 was designed to work inside of a sandbox but never explicitly set up a
 sandbox in the application.
 The indicating code consists of adding extra permission checks if the applicati
on was inside of a sandbox, (**may want to explain doPrivileged here**)
 using doPrivileged calls to avoid checking the permissions of all classes
 on the stack, or ensuring that sections of the application would work within
 a sandbox using test cases.
 This category was further subdivided into applications which altered execution
 inside the main application (meaning extra permission check or calling
 doPrivileged) and applications which only contined test cases that interacted
 with the sandbox.
 The only contained test cases category also includes one application, system-ru
les, which was a utility for test cases.
 The final category, not interacting with a SecurityManager at all, means
 that the application either explicitly referenced the SecurityManager in
 comments but not in the source code or the application defined a class
 containing the name SecurityManger but the defined class did not extend
 java.lang.SecurityManager in any way.
\end_layout

\begin_layout Standard
After inspecting the 29 applications in the filtered Qualitas dataset, the
 applications were classified based on how they interacted with the SecurityMana
ger.
 (## probably should make this a table ##) Five of the applications set
 and then changed the SecurityManager as the program was running.
 Six of the applications contained code that set a SecurityManager, but
 did not change the SecurityManager after it was set.
 Thirteen applications contianed code that indicated they were designed
 to run inside a SecurityManager.
 Of those thirteen applications, ten contained code in the application that
 altered behavior when a SecurityManager was set.
 Three of those thirteen applications only interacted with a SecurityManager
 in test cases.
 The remaining five applications in the filtered Qualitas dataset were false
 positives.
\end_layout

\begin_layout Standard
The GitHub dataset also contained similar results.
 Three of the seventeen applications set and then changed the SecurityManager.
 One application set a SecurityManager and then did not change the set SecurityM
anager as the program was running.
 Eight applications contained code that indicated they were designed to
 work inside a sandbox if one was set.
 Of those eight applications, three altered execution if a sandbox was set
 while five of the eight applications only interacted with a sandbox in
 test cases.
 The other five applications were false positives.
\end_layout

\begin_layout Subsection
Non-security uses of the Sandbox
\end_layout

\begin_layout Standard
When investigating the applications in both of the datasets, the first surprisin
g discovery was that applications used in the sandbox in ways that were
 not designed to increase the security of the system.
 Specifically, the sandbox was used to enforce architectural constraints
 when interacting with other applications and to reduce development complexity
 in web application development.
\end_layout

\begin_layout Subsubsection
Enforcing Architectural Constraints 
\end_layout

\begin_layout Standard
Java applications commonly call 
\family typewriter
System.exit()
\family default
 if the application throws a non-recoverable error condition.
 However, this error handling method causes problems when applications work
 together, specifically when an application calls another application which
 will exit on an error.
 The problem with this interaction is that when the called application executes
 the 
\family typewriter
System.exit()
\family default
 line, the called application kills the calling application as well.
 The calling application is killed along with the called application because
 the execution of 
\family typewriter
System.exit()
\family default
 stops the virtual machine instance in which both applications are running.
\end_layout

\begin_layout Standard
In many cases, the ability for the called application to kill the calling
 application is an unintended side-effect.
 Thus the calling application needs to enforce the architectural constraint
 that called applications can not terminate the execution of the calling
 application.
 To enforce this architectural constraint, Java applications that call other
 applications set a SecurityManager that prevents 
\family typewriter
System.exit()
\family default
 calls.
 The new SecurityManager usually stops all calls to 
\family typewriter
System.exit()
\family default
 while the new SecurityManager is set and, if a SecurityManager was previously
 set, the new SecurityManager defers all other security checks to the previously
 set SecurityManager.
 When the calling application determines that the called application has
 finished, the calling application usually restores the previously set SecurityM
anager if one exists.
\end_layout

\begin_layout Standard
One example of an application preventing another application from calling
 
\family typewriter
System.exit()
\family default
 is Eclipse in Qualitas which calls Ant.
 When Ant reaches an unrecoverable error condition, Ant will call 
\family typewriter
System.exit()
\family default
 to terminate the compilation.
 However, Eclipse wants to continue executing and report an error to the
 user if Ant runs into a error condition.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}[b]{0.95
\backslash
linewidth} 
\end_layout

\begin_layout Plain Layout


\backslash
setbox0=
\backslash
vbox{%
\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=691,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(new AntSecurityManager(originalSM, Thread.currentThre
ad()));
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

 
\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=703,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   getCurrentProject().executeTargets(targets); 
\backslash

\backslash
Note: Ant is executed on this line
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=703,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   finally {
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=725,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   if (System.getSecurityManager() instanceof AntSecurityManager) { 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(originalSM); 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim} 
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout


\backslash
hspace*{0.1cm}
\end_layout

\begin_layout Plain Layout


\backslash
fbox{
\backslash
box0} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Shown in the code above, on line 691 Eclipse sets a SecurityManager to prevent
 Ant from calling 
\family typewriter
System.exit()
\family default
.
 After performing some other checks, Ant is executed.
 Then after handling other error conditions, the original SecurityManager
 is restored.
\end_layout

\begin_layout Standard
Another example of enforcing the architectural constraint occurs in GJMan
 in the GitHub data set.
 The code references a blog page describing this problem and the implemented
 solution: http://www.jroller.com/ethdsy/entry/disabling_system_exit.
 The code reads 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt, firstnumber=703,frame=single,fonts
ize=
\backslash
scriptsize,framesep=2mm,xrightmargin=0.1cm]
\end_layout

\begin_layout Plain Layout

   public static void apply() { 
\end_layout

\begin_layout Plain Layout

     final SecurityManager securityManager = new SecurityManager() { 
\end_layout

\begin_layout Plain Layout

       public void checkPermission( Permission permission ) { 
\end_layout

\begin_layout Plain Layout

         if( permission.getName().startsWith("exitVM") ) { 
\end_layout

\begin_layout Plain Layout

           throw new Exception() ; 
\end_layout

\begin_layout Plain Layout

         } 
\end_layout

\begin_layout Plain Layout

       } 
\end_layout

\begin_layout Plain Layout

     } ; 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager( securityManager ) ; 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   public static void unapply() { 
\end_layout

\begin_layout Plain Layout

     System.setSecurityManager( null ) ; 
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code contains the allow method which creates a SecurityManager that
 stops System.exit calls and the sets the created SecurityManager as the
 Sandbox for the Java Virtual Machine.
 The file also includes a method to remove the SecurityManager and removes
 the Sandbox from the Java Virtual Machine.
 While GJMan does not execute these lines explicitly, GJMan is written to
 be a library for other applications, so this file is likely used in other
 applications.
 
\end_layout

\begin_layout Standard
In total, we found 3 applications using a variation of this technique: Eclipse,
 GJMan, and AspectJ.
 While this technique is useful in applying architectural constraints, and
 probably the best architectural solution available in Java at the moment,
 this technique is likely to cause problems when applications desire the
 sandbox to also enforce security constraints.
 The reason this technique creates problems when trying to enforce security
 constraints is that the sandbox must be set in a state which it can be
 dynamically removed, otherwise the calling application could never terminate.
 By allowing the sandbox to be dynamically removed, the application must
 be carefully written to avoid allowing malicious code to turn off the sandbox.
\end_layout

\begin_layout Standard
(**** may need to move the next paragraph in the future ****)
\end_layout

\begin_layout Standard
One example of the difficulty of creating a sandbox that can be turned on
 and off dynamically was found in Freemind.
 Freemind is a diagram drawing tool that allows users to execute Groovy
 scripts on the current drawing.
 The developers of Freemind implemented the sandbox so that it would turn
 on before executing a user run script and would turn off after the script
 finished executing.
 The security goals of the Freemind sandbox was to stop malicious scripts
 from creating files, executing programs on the machine, and creating network
 sockets to establish connections with outside entities.
 Unfortunately, in the version we analyzed (*** should put version somewhere
 ***), these goals were not achieved.
 By implementing the SecurityManager in the old SecurityManager style, explicitl
y removing privileges, multiple dangerous permissions were left, such as
 the ability to alter private variables with reflection.
 This privilege made it trivial to remove the currently set SecurityManager
 inside a Groovy script, thus turning off the sandbox, and allowing the
 script to create files.
 The authors submitted a sample exploit to the Freemind development group
 and made recommendations on how to improve the security of the Freemind
 sandbox.
 (*** also should probably mention something about the SecurityManager indirecti
on ***).
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Reducing-Web-Application-Complexity"

\end_inset

Reducing Complexity In Web Application Development
\end_layout

\begin_layout Standard
When Java web applications are run inside modern web browser, the application
 is sandboxed to protect the machine which hosts the browser.
 When the sandbox is set up, applications have to work inside the restrictions
 of the sandbox, meaning that applications are only approved to use the
 permissions allowed in the standard web browser sandbox.
 
\end_layout

\begin_layout Standard
To support applications which need to use permissions unavailable in the
 standard web browser sandbox, web browsers allow Java web applications
 to run without a sandbox after obtaining user approval.
 Developers, aware that users can turn off the sandbox, can develop applications
 in a way that require the sandbox to be explicitly turned off.
 Specifically, these applications ensure that the sandbox is off at the
 start of executing the web application.
 If a default sandbox is set, this check will cause the applications to
 crash with a SecurityException.
 Thus, the only way to run the applications are to turn off the sandbox.
\end_layout

\begin_layout Standard
In total we found two applications that were using this method: Eclipse
 in Qualitas and Timelag in Github.
 Since malicious applications are also known to turn off the sandbox, i.e.
 null the SecurityManager, it is important to carefully distinguish between
 a benign application which turns off the sandbox and a malicious application
 which turns off the sandbox.
 In the case where the application attempts to turn off the sandbox when
 starting the application and the application does not attempt to ensure
 the turn off attempt will succeed, it is determined that the application
 is trying to check if a sandbox is set and, if so, stop the application.
 On the other hand, applications which attempt to ensure that the sandbox
 is turned off, even when one is set, are likely malicious.
\end_layout

\begin_layout Standard
Eclipse contains the following code section in the file WebStartMain.java
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{table}[h] 
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}[b]{0.95
\backslash
linewidth} 
\end_layout

\begin_layout Plain Layout


\backslash
setbox0=
\backslash
vbox{%
\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,firstnumber=22,fontsize=
\backslash
scriptsize,framesep=2mm]
\end_layout

\begin_layout Plain Layout

   /** 
\end_layout

\begin_layout Plain Layout

   * The launcher to start eclipse using webstart.
 To use this launcher, the client 
\end_layout

\begin_layout Plain Layout

   * must accept to give all security permissions.
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{Verbatim}[numbers=left,numbersep=-10pt,fontsize=
\backslash
scriptsize,firstnumber=55,framesep=2mm,commandchars=
\backslash

\backslash

\backslash
{
\backslash
}]
\end_layout

\begin_layout Plain Layout

   public static void main(String[] args) 
\backslash
{ 
\end_layout

\begin_layout Plain Layout

   System.setSecurityManager(null); 
\backslash
textbf{//TODO Hack so that when the classloader loading the fwk is created
 we don't have funny permissions.
 This should be revisited.
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{Verbatim}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
hspace*{0.1cm}
\end_layout

\begin_layout Plain Layout


\backslash
fbox{
\backslash
box0} 
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage} 
\end_layout

\begin_layout Plain Layout


\backslash
end{table}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Eclipse comments show that the attempt to turn off the sandbox was done
 to avoid the permission issues caused by the default sandbox for Java Web
 Start.
 Timelag also contains the 
\family typewriter
System.setSecurityManager(null);
\family default
 line as the first line of its main function in the file JTimelag.java but
 does not contain any comments.
 So the motivation behind turning off the sandbox at the beginning of execution
 had to be inferred.
\end_layout

\begin_layout Subsection
Changing the SecurityManager for Security Purposes
\end_layout

\begin_layout Standard
-talk about how applications provide the option to set and remove security
 managers, also give an example
\end_layout

\begin_layout Standard
- talk about how Ant restricts the applications for a small section
\end_layout

\begin_layout Standard
- can talk about wildflySecurityManager
\end_layout

\begin_layout Standard
- talk about batik and the demo where they set two SMs
\end_layout

\begin_layout Section
Mitigations
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Methodology"

\end_inset

 we discussed (1) three claims that would lead to Java exploit mitigations
 if validated and (2) how we went about validating them.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Research-Questions-and"

\end_inset

 we discussed additional research questions we answered while successfully
 validating the strong claim and the overall results of our empirical analysis
 of the open source Java landscape.
 The results included two backwards-compatible rules that can be enforced
 to stop current exploits.
 In this section we discuss the implementation and evaluation of a tool
 that implements the privilege escalation and SecurityManager rules.
 We evaluated this tool in collaboration with a large aerospace company
 that is currently working on deploying the tool to workstations that belong
 to highly targeted employees.
 
\end_layout

\begin_layout Subsection
Implementation Using JVMTI
\end_layout

\begin_layout Standard
Prior work has made an effort to prevent exploits in the native libraries
 used by language runtimes such as Java's 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010,li_quarantine:_2011,siefers_robusta:_2010,sun_jvm-portable_2012"

\end_inset

, and the machine learning community has put some effort into detecting
 malicious applets and drive-by-downloads using similar technologies 
\begin_inset CommandInset citation
LatexCommand cite
key "cova_detection_2010,ford_analyzing_2009,helmer_anomalous_2001,schlumberger_jarhead_2012"

\end_inset

.
 We implemented a tool in JVMTI to pro-actively stop exploits written directly
 in the Java programming language to exploit other Java code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Our tool, Java Sandbox Fortifier, is open source and hosted on GitHub at
 https://github.com/SecurityManagerCodeBase/JavaSandboxFortifier.
 REVIEWERS: INSPECTING THIS GITHUB PROJECT MAY REVEAL THE AUTHORS' IDENTITIES.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
JVMTI is a native interface that is intended to be used to create analysis
 tools for Java such as profilers, debugging, monitoring, and thread analysis
 tools.
 Tools that use JVMTI are called agents and are attached to a running Java
 application at some configuration specific point in the application's lifecycle.
 The interface allows an agent to set capabilities that enable the tool
 to intercept events such as class and thread creation, field access and
 modifications, breakpoints, and much more.
 After acquiring the necessary capabilities, a JVMTI agent registers callbacks
 for the events they want to receive.
 JVMTI contains a rich API, hooks for instrumenting the bytecode of loaded
 classes, and provides access to the JNI, all of which can be used to perform
 nearly any operation on classes, threads, etc.
 that a tool may want to perform at the time when an event occurs.
 Our agent must intercept three events to enforce the privilege escalation
 and SecurityManager rules.
 Enforcement of these rules is discussed in detail in subsections below.
\end_layout

\begin_layout Standard
Our agent was written in C++.
 524 lines of code were required to enforce the privilege escalation rule
 while 377 lines of code were required for the SecurityManager rule when
 counted using the Linux tool 
\family typewriter
wc
\family default
.
 This code constitutes the attack surface for our tool because a malicious
 class could potentially craft information such as class, field, or method
 name to exploit an issue in the rule enforcement code when the information
 is passed to the appropriate callback.
 The risk here is greatly reduced both by the fact that there is little
 attack surface to inspect and due to the previously cited work that can
 be applied to our tool.
 For example, the software-based fault isolation subset of Robusta 
\begin_inset CommandInset citation
LatexCommand cite
key "siefers_robusta:_2010"

\end_inset

 can be applied to our tool to isolate the effects of an exploit.
 Using a security kernel for Java similar to Cappo's for Python 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010"

\end_inset

, our tool could be isolated to its own security layer with only access
 to the information it gets from JVMTI.
 We did not attempt to apply these solutions because the required tools
 and code are not publicly available, which would make it difficult if not
 impossible for most people to use our tool.
\end_layout

\begin_layout Standard
Our agent may be configured to run in enforce mode or in monitor mode.
 In enforce mode a violation of either rule causes the agent to log the
 offending behavior and terminate the JVM to which the agent is attached.
 In monitor mode the agent simply logs the offending behavior but leaves
 the JVM's execution of the application untouched.
 In either case a popup is shown to the user to let them know why their
 Java application was terminated assuming the agent has been configured
 to show popups (this was made configurable to prevent popups on headless
 servers).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:A-popup-from"

\end_inset

 shows an example of a popup from when an exploit was caught breaking the
 privilege escalation rule.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename rule_violation_popup.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A popup from our agent after it caught an exploit breaking the privilege
 escalation rule.
\begin_inset CommandInset label
LatexCommand label
name "fig:A-popup-from"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Enforcing the Privilege Escalation Rule
\end_layout

\begin_layout Standard
To enforce the privilege escalation rule we must ensure that if a self-protectin
g security manager has been set, classes do not load or cause the loading
 of more privileged classes unless the privileged class is in a restricted-acces
s package.
 
\shape italic
Restricted-access packages
\shape default
 are those that are public but that are not intended to be directly used
 by typical Java applications because they are meant for internal JRE use
 only.
 These packages are listed in the 
\family typewriter
package.access
\family default
 property in the 
\family typewriter
java.security.Security
\family default
 class.
 The only ways to directly access packages listed in this property are to
 exploit a vulnerability in a class that can access them or to allow access
 via the 
\family typewriter
accessClassInPackage
\family default
 permission, but allowing this permission for the protection domain that
 encapsulates a Java application's classes would make the security manager
 defenseless (see table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:defenseless-permissions"

\end_inset

).
\end_layout

\begin_layout Standard
We must allow a class to indirectly load a class in a restricted-access
 package because classes in these packages are often used by JRE classes
 that an application is allowed to use.
 For example, many of the classes in the 
\family typewriter
java.lang.reflect
\family default
 package are backed by classes in the 
\family typewriter
sun
\family default
 package, the latter of which is a restricted-access package that contains
 the internal implementations for many Java features.
\end_layout

\begin_layout Standard
Our agent registers for the 
\family typewriter
ClassPrepare
\family default
 event, which allows it to inspect a class after it is fully loaded but
 just before any of its code is executed.
 Assuming the loaded class is not in a restricted-access package, the agent
 inspects the stack frame to determine which class caused the new class
 to be loaded.
 The agent must get the protection domains for both classes, but this can
 not be done by calling the necessary Java methods
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
Class.getProtectionDomain()
\end_layout

\end_inset

 via the JNI from the agent because the Java calls will be performed with
 the same permissions as the application the agent is attached to.
 Most applications where this operation is relevant do not have the necessary
 permission to get a protection domain
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\family typewriter
RuntimePermission(
\begin_inset Quotes eld
\end_inset

getProtectionDomain
\begin_inset Quotes erd
\end_inset

)
\end_layout

\end_inset

 because it would allow a malicious class to probe the policy to determine
 which, if any, malicious operations it can perform.
 Due to the fact that JVMTI agents are loaded into the JRE as a shared-library,
 we instead load libjvm.so (jvm.dll on Microsoft Windows) to call JVM functions
 without security checks.
 Our agent leverages this ability to call the 
\family typewriter
GetProtectionDomain
\family default
 JVM function to get the protection domains.
 
\end_layout

\begin_layout Standard
With both protection domains the implementation of the agent as of the time
 of this writing simply checks to see if the loaded class's protection domain
 has 
\family typewriter
AllPermissions
\family default
 while the class that caused the loading doesn't.
 If the latter is true, the privilege escalation rule has been violated.
 This specific check was used because it is fast, simple, and all privileged
 class allow 
\family typewriter
AllPermissions
\family default
 under known circumstances.
 It would be easy to update this check to instead ensure that every permission
 in the loaded class's protection domain is also in the other protection
 domain to handle cases we are currently not aware of.
\end_layout

\begin_layout Subsubsection*
Enforcing the SecurityManager Rule
\end_layout

\begin_layout Standard
The SecurityManager rule is enforced by registering 
\family typewriter
FieldModification
\family default
 and 
\family typewriter
FieldAccess
\family default
 events for the 
\family typewriter
security
\family default
 field of the 
\family typewriter
System
\family default
 class.
 These events notify our agent every time the field is written to or read
 by any Java code.
 The agent stores a shadow copy of the application's most recent security
 manager to have a trusted copy of the manager that can be used to check
 for violations of this rule.
 In a typical deployment, the agent is loaded by a JVM before the hosted
 Java application's code has begun executing, but if a security manager
 is set on the command line that runs the application, the initial security
 manager would not be caught by the modification event because the write
 happens before the agent is loaded.
 To solve this problem, the shadow copy is first initialized by calling
 
\family typewriter
System.getSecurityManager()
\family default
 when the agent is loaded by a JVM.
 After this point, the shadow copy is only updated by the modification event,
 which receives the new manager as a parameter from the JVM.
\end_layout

\begin_layout Standard
Modification events are used to detect any change to a self-protecting security
 manager.
 When the field is written, the agent checks the shadow copy of the manager.
 Assuming the shadow copy is 
\family typewriter
null
\family default
, the agent knows the manager is being set for the first time and checks
 to see if the new manager is self-protecting.
 If the manager is self-protecting the agent simply updates the shadow copy,
 otherwise the agent will also drop into monitor mode when enforce mode
 is configured because the rules cannot be enforced for applications that
 use defenseless managers.
 Future modifications are logged as a violation of the rule and trigger
 the operation relevant to the agents current mode as discussed above.
\end_layout

\begin_layout Standard
Access events are used to detect type confusion attacks against the manager.
 The modification event we register will not be triggered when the manager
 is changed due to a type confusion attack.
 When a type confusion attack is used to masquerade a malicious class as
 the 
\family typewriter
System
\family default
 class, the malicious copy will have different internal JVM identifiers
 for the field that stores the manager and the class itself even though
 writing to the field in one class also updates it in the other class.
 The modification and access events are registered for specific field and
 class identifiers, thus the events are not triggered for operations on
 the malicious version.
 We leverage the mismatch this causes between the set security manager and
 our shadow copy in the access event by checking to see if the manager that
 was just read has the same internal JVM reference as our shadow copy.
 When the two references do not match the manager has been changed as the
 result of a malicious class masquerading as the 
\family typewriter
System
\family default
 class.
 Type confusion attacks may also be used to masquerade a class as a privileged
 class loader to elevate the privileges of a payload class that disables
 the manager, but this scenario is detected by the modification event.
\end_layout

\begin_layout Subsection
Effectiveness in Stopping Exploits
\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Discuss the different deployment options to work around the slowdown
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
How to write exploits now...
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
