#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Fortifying the Java Sandbox
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Related science:
\end_layout

\begin_layout Plain Layout
1.
 Most Dangerous Code in the World
\end_layout

\begin_layout Plain Layout
2.
 Zero Day Vulnerabilities (Before We Knew It)
\end_layout

\begin_layout Plain Layout
3.
 Password Manager insecurity paper (from Sep 2014)
\end_layout

\begin_layout Plain Layout
Related science probably makes sense to go right before the flag post paragraph.
\end_layout

\begin_layout Plain Layout
This section should define JVMTI so that we can use it everywhere else but
 don't explain much about what it is here -- shouldn't be hard to do (cite
 the docs when doing it)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Standard
The Java sandbox was designed to enable the safe execution of code from
 untrusted sources.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Sandbox-high-level-summary"

\end_inset

 summarizes components of the sandbox that are relevant to this work.
 Essentially, when a class loader loads a class from some location (e.g.,
 network, filesystem, etc.) the class is assigned a code source.
 The code source is used to indicate the origin of the code while it is
 loaded in the JRE and to associate the class with a protection domain.
 Protection domains segment classes into different groups that are assigned
 a security policy.
 Each domain imposes one policy on the classes it contains where a policy
 includes a set of permissions that grant the contained classes the ability
 to perform operations such as writing to the filesystem, accessing the
 network, using certain reflection features, etc.
 (see a more complete list at 
\begin_inset CommandInset citation
LatexCommand cite
key "_permissions_2014"

\end_inset

).
 Each JRE contains a default policy configuration that grants applications
 from the local filesystem all permissions and applets from the web a strict
 set of permissions that prevent them from performing malicious operations
 on the host system.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This probably not the exact graphic we want to use in this paper (too PowerPoint
y) but we need something like this for this section.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename sandbox_overview.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A high-level summary of the Java sandbox as it pertains to this work.
\begin_inset CommandInset label
LatexCommand label
name "fig:Sandbox-high-level-summary"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To enforce the security policy, a security manager must be set (typically
 by calling
\family typewriter
 System.setSecurityManager(new SecurityManger())
\family default
).
 The security manager acts as the gateway to policy enforcement in the Java
 sandbox.
 Whenever Java code wants to ensure a caller has the correct permissions
 to execute protected code, the callee must query the security manager.
 For example, if an application attempts to use a JRE class to write to
 a file (e.g java.io.FileOutputStream), the JRE class will ensure that the
 caller has permission to write to the file before performing the write.
 When such a query is initiated, the security manager walks the stack frames
 for the current calling context to ensure every class in the context has
 the correct permissions or a privileged caller has marked the context as
 privileged.
 If the context is not marked as privileged and even one class in the stack
 frame does not have the correct permissions, the manager will throw a SecurityE
xception.
 Stack-based access control is discussed in more detail in 
\begin_inset CommandInset citation
LatexCommand cite
key "banerjee_stack-based_2005,besson_stack_2004,d._s._wallach_understanding_1998,erlingsson_irm_2000,fournet_stack_2002,pistoia_beyond_2007,zhao_type_2005"

\end_inset

.
 Typically a security manager is automatically set by the JRE when a class
 is loaded using class loaders for sources that are nearly always untrusted
 such as applets.
\end_layout

\begin_layout Standard
Malicious drive-by-downloads using Java applets as the vector were widely
 reported between 2011 and 2013.
 While the security manager should prevent applets from performing operations
 that are useful to a malicious actor, vulnerabilities in the JRE were leveraged
 to set the manager to null.
 The latter operation effectively disables the Java sandbox, thus allowing
 previously constrained classes to perform any operation that the JRE can
 perform.
 These vulnerabilities tend to fall into one of two categories: those that
 exploit a type confusion vulnerability to set the security manager to null
 and those that exploit a confused deputy vulnerability 
\begin_inset CommandInset citation
LatexCommand cite
key "hardy_confused_1988"

\end_inset

 in a privileged JRE class to null the security manager.

\series bold
 
\end_layout

\begin_layout Standard
In the case of type confusion a vulnerability is exploited to break type
 safety, thus allowing the attacker to craft an object that can perform
 operations as if it is an instantiation of a class of a different type
 or as if it is an already existing object of a different type.
 For example, attackers will craft objects that either (1) point to the
 System class to cause any operation they perform to happen on the real
 System class, thus allowing them to directly alter the field where the
 security manager is stored or (2) act as if they have the same type as
 a privileged class loader to load a payload class with all permissions
 (see CVE-2012-0507 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_0507"

\end_inset

).
 In the case of a confused deputy the exploit often attacks a privileged
 class that is accessible by any class to obtain an instance of a vulnerable
 privileged class that is only accessible to other privileged classes.
 The restricted-access class is targeted because it contains a vulnerability
 that can be leveraged to execute privileged code, typically to null the
 security manager (see CVE-2012-4681 
\begin_inset CommandInset citation
LatexCommand cite
key "_vulnerability_2012_4681"

\end_inset

).
 While it is possible for an accessible privileged class to contain a vulnerabil
ity that will allow an attacker to null the manager more directly, these
 classes are typically implemented more carefully to avoid these types of
 issues.
\end_layout

\begin_layout Standard
Many of the recent vulnerabilities would not have been introduced if the
 JRE was developed while strictly following 
\begin_inset Quotes eld
\end_inset

The CERT Oracle Secure Coding Standard for Java
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "long_cert_2011"

\end_inset

.
 For example, Svoboda 
\begin_inset CommandInset citation
LatexCommand cite
key "svoboda_anatomy_blog_2013,svoboda_anatomy_2014"

\end_inset

 pointed out that CVE-2012-0507 and CVE-2012-4681 were caused by violating
 a total of six different secure coding rules and four guidelines.
 In the typical cases following just one or two of the broken rules and
 guidelines would have prevented a serious exploit.
 In the rest of this paper we concern ourselves with ways to fortify the
 Java sandbox without breaking backwards compatibility and not with the
 specifics of particular exploits.
\end_layout

\begin_layout Standard
For the purpose of fortifying the sandbox, we distinguish between self-protectin
g and defenseless security managers.
 A 
\shape italic
self-protecting
\shape default
 security manager enforces a policy that prevents encapsulated classes from
 changing the manager or the policy it enforces.
 In contrast, a 
\shape italic
defenseless
\shape default
 security manager allows encapsulated classes to change the manager or the
 enforced policy.
 A defenseless manager does little to improve the security posture of the
 encapsulated Java application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:defenseless-permissions"

\end_inset

 summarizes the set of permissions used to distinguish between self-protecting
 and defenseless security managers.
 A manager enforcing a policy that contains even one of the listed permissions
 is considered to be defenseless.
 A subset of the permissions in this list were identified in 
\begin_inset CommandInset citation
LatexCommand cite
key "security_explorations_2012"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Permission
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Risk
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(createClassLoader)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load classes into any protection domain
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(accessClassInPackage.sun)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access powerful restricted-access internal classes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RuntimePermission(setSecurityManager)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Change the application's current security manager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ReflectPermission(suppressAccessChecks)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allow access to all class fields and methods as if they are public
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FilePermission(ALL FILES, write | execute)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write to or execute any file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SecurityPermission(setPolicy)
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Modify the application's permissions at will
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A security manager enforcing a policy that contains any permission in this
 list is defenseless.
\begin_inset CommandInset label
LatexCommand label
name "tab:defenseless-permissions"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Methodology
\begin_inset CommandInset label
LatexCommand label
name "sec:Methodology"

\end_inset


\end_layout

\begin_layout Standard
While Java exploits tend to follow one of several high-level patterns, the
 individual vulnerabilities they exploit are diverse in their form and their
 location in the JRE.
 Given this complexity, we must understand how benign Java applications
 interact with the Java sandbox to design justifiable mitigations.
 The security manager is the means by which applications interact with the
 Java sandbox, thus we undertook an empirical analysis consisting of static,
 dynamic, and manual inspections of the open source Java application landscape
 to investigate benign uses of the security manager.
 Our empirical analysis aimed to validate the following hypotheses, roughly
 categorized by the strength of the mitigation that is possible if the hypothesi
s is true:
\series bold

\begin_inset Newline newline
\end_inset

Weak Hypothesis:
\series default
 
\shape italic
Benign applications do not disable the security manager.
\series bold
\shape default

\begin_inset Newline newline
\end_inset

Moderate Hypothesis:
\series default
 
\shape italic
Benign applications do not weaken the security manager by allowing previously
 disallowed operations.
\series bold
\shape default

\begin_inset Newline newline
\end_inset

Strong Hypothesis:
\series default
 
\shape italic
Benign applications do not change the security manager or the enforced policy
 in any way if a self-protecting security manager has been set.
\end_layout

\begin_layout Standard
If the weak hypothesis is true, we can monitor applications to ensure they
 do not set the manager to null.
 This would prevent exploits as they are currently written, but it would
 be simple for attackers to shift to weakening the policies enforced by
 the manager or to replace the current manager with one that never throws
 a SecurityException.
 Successful validation of the moderate hypothesis would be stronger because
 it would prevent the manager and policy from being weakened, but the implementa
tion of this mitigation would be potentially problematic because one would
 have to determine when a permission can be changed without creating a security
 vulnerability.
 This is difficult because it requires context a tool may not have.
 For example, if a permission to write to a file is replaced by a permission
 to write to another file, how does a tool know if the policy is weaker
 or not? The strongest mitigation is possible if the strong hypothesis is
 true because it achieves a similar effect to the moderate mitigation while
 being substantially easier to implement.
\end_layout

\begin_layout Standard
We turned to the Qualitas Corpus (QC) 
\begin_inset CommandInset citation
LatexCommand cite
key "QualitasCorpus:APSEC:2010"

\end_inset

 and GitHub to form a dataset of applications that use the security manager.
 To sort out relevant applications in QC we performed a simple grep of each
 application's source code to find the keyword 
\shape italic
SecurityManager
\shape default
.
 Assuming any instance of the keyword was found, we included the application
 in our dataset.
 This reduced the overall set of applications to inspect from 112 to 29.
 While this led to the inclusion of applications that had the keyword in
 comments or in unit tests that would not appear in production code, these
 applications were easily sorted out in later steps.
 We performed a similar process using the GitHub search feature configured
 to show source code, Java applications, and the most relevant results.
 At the time of our search, GitHub did not group results by project, thus
 we searched through the first 20 pages and found 17 unique projects that
 used the security manager to add to the dataset.
 While the page limit meant we only looked at a few hundred of the nearly
 100,000 results returned, we believe this procedure was sufficient to ensure
 our dataset is representative of how open source Java applications use
 the security manager.
\end_layout

\begin_layout Standard
We created static and dynamic analysis tools to further sort through the
 dataset before manually inspecting projects.
 Our static analysis is a plugin for FindBugs 
\begin_inset CommandInset citation
LatexCommand cite
key "hovemeyer_finding_2004"

\end_inset

 that uses a dataflow analysis to determine what initialized security managers
 may be set as System security manager by calling 
\family typewriter
System.setSecurityManager
\family default
.
 We created a dynamic analysis using JVMTI
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://docs.oracle.com/javase/7/docs/technotes/guides/jvmti/
\end_layout

\end_inset

.
 Our dynamic analysis set a modification watch on the 
\family typewriter
security
\family default
 field of Java's System class.
 The security field is a private and static field that stores the SecurityManage
r object that will be used by all JRE classes when making security policy
 decisions for the running Java application.
 The watch printed out the class name, source file name, and line of code
 where any write to the security field took place.
 The printed message contained a special notice if the security manager
 was being set to 
\family typewriter
null
\family default
.
 After running both of these tools on each project we were armed with the
 information required to further narrow our manual inspection efforts: which
 applications change the security manager, where they make the change, and
 where SecurityManager objects are initialized.
\end_layout

\begin_layout Standard
We split the applications that used the security manager between two reviewers.
 The reviewers utilized a checklist to ensure that they consistently inspected
 each application.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Summary-of-checklist"

\end_inset

 provides a summary of the items on our checklist; the full list provides
 details on carrying out each step.
 After performing a manual inspection, the reviewer ran the dynamic analysis
 on the application again, but this time with an emphasis on running executions
 that were known to exercise the security manager to ensure we didn't miss
 an important execution.
 Finally, the reviewer wrote a summary of how the application used the security
 manager with an emphasis on points that support or reject each hypotheses.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This table kind of sucks.
 Is there something better we can do?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Summary of checklist for manual reviews in the empirical analysis of security
 manager usage.
\begin_inset CommandInset label
LatexCommand label
name "tab:Summary-of-checklist"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify call sites for setSecurityManager
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify references to SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify possible values for SecurityManager objects that reach a call site
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Research Questions and Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Research-Questions-and"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
How commonly are SM's used?
\end_layout

\begin_layout Plain Layout
Why do apps use the SM?
\end_layout

\begin_layout Plain Layout
What are the common mistakes made by apps using the SM?
\end_layout

\begin_layout Plain Layout
This section should cover the rules too (or maybe mitigations should do
 it up front?) -- call them privilege escalation and SecurityManager rules
 or change the names for the rules used in Mitigations section
\end_layout

\end_inset


\end_layout

\begin_layout Section
Mitigations
\end_layout

\begin_layout Standard
In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Methodology"

\end_inset

 we discussed (1) three hypotheses that would lead to Java exploit mitigations
 if validated and (2) how we went about validating them.
 In section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Research-Questions-and"

\end_inset

 we discussed additional research questions we answered while successfully
 validating the strong hypothesis and the overall results of our empirical
 analysis of the open source Java landscape, including two backwards-compatible
 rules that can be enforced to stop current exploits.
 In this section we discuss the implementation and evaluation of a tool
 that implements the privilege escalation and SecurityManager rules.
 We evaluated this tool in collaboration with a large aerospace company
 that is currently working on deploying the tool to workstations that belong
 to highly targeted employees.
 
\end_layout

\begin_layout Subsection
Implementation Using JVMTI
\end_layout

\begin_layout Standard
Prior work has made an effort to prevent exploits in the native libraries
 used by language runtimes such as Java's 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010,li_quarantine:_2011,siefers_robusta:_2010,sun_jvm-portable_2012"

\end_inset

, and the machine learning community has put some effort into detecting
 malicious applets CITE_THEM.
 We implemented a tool in JVMTI to pro-actively stop exploits written directly
 in the Java programming language to exploit other Java code
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Our tool, Java Sandbox Fortifier, is open source and hosted on GitHub at
 https://github.com/SecurityManagerCodeBase/JavaSandboxFortifier.
 REVIEWERS: INSPECTING THIS GITHUB PROJECT MAY REVEAL THE AUTHORS' IDENTITIES.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
JVMTI is a native interface that is intended to be used to create analysis
 tools for Java such as profilers, debugging, monitoring, and thread analysis
 tools.
 Tools that use JVMTI are called agents and are attached to a running Java
 application at some configuration specific point in the application's lifecycle.
 The interface allows an agent to set capabilities that enable the tool
 to intercept events such as class and thread creation, field access and
 modifications, breakpoints, and much more.
 After acquiring the necessary capabilities, a JVMTI agent registers callbacks
 for the events they want to receive.
 JVMTI contains a rich API, hooks for instrumenting the bytecode of loaded
 classes, and provides access to the JNI, all of which can be used to perform
 nearly any operation on classes, threads, etc.
 that a tool may want to perform at the time when an event occurs.
 Our agent must intercept three events to enforce the privilege escalation
 and SecurityManager rules.
 Enforcement of these rules is discussed in detail in subsections below.
\end_layout

\begin_layout Standard
Our agent was written in C++.
 524 lines of code were required to enforce the privilege escalation rule
 while 377 lines of code were required for the SecurityManager rule when
 counted using the Linux tool 
\family typewriter
wc
\family default
.
 This code constitutes the attack surface for our tool because a malicious
 class could potentially craft information such as class, field, or method
 name to exploit an issue in the rule enforcement code when the information
 is passed to the appropriate callback.
 The risk here is greatly reduced both by the fact that there is little
 attack surface to inspect and due to the previously cited work that can
 be applied to our tool.
 For example, the software-based fault isolation subset of Robusta 
\begin_inset CommandInset citation
LatexCommand cite
key "siefers_robusta:_2010"

\end_inset

 can be applied to our tool to isolate the effects of an exploit.
 Using a security kernel for Java similar to Cappo's for Python 
\begin_inset CommandInset citation
LatexCommand cite
key "cappos_retaining_2010"

\end_inset

, our tool could be isolated to its own security layer with only access
 to the information it gets from JVMTI.
 We did not attempt to apply these solutions because the required tools
 and code are not publicly available, which would make it difficult if not
 impossible for most people to use our tool.
\end_layout

\begin_layout Subsubsection*
Enforcing the Privilege Escalation Rule
\end_layout

\begin_layout Subsubsection*
Enforcing the SecurityManager Rule
\end_layout

\begin_layout Subsection
Effectiveness in Stopping Exploits
\end_layout

\begin_layout Subsection
Performance
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Discuss the different deployment options to work around the slowdown
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
How to write exploits now...
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "references"
options "ieeetr"

\end_inset


\end_layout

\end_body
\end_document
